<!doctype html><html lang=en class="js csstransforms3d"><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.127.0"><meta name=description content="Tutoriel sur Kubernetes"><meta name=author content="Maxime Calves"><link rel=icon href=/kubernetes-tutorial/images/favicon.png type=image/png><title>Volumes :: Kubernetes Tutoriel</title>
<link href=/kubernetes-tutorial/css/nucleus.css?1719308635 rel=stylesheet><link href=/kubernetes-tutorial/css/fontawesome-all.min.css?1719308635 rel=stylesheet><link href=/kubernetes-tutorial/css/hybrid.css?1719308635 rel=stylesheet><link href=/kubernetes-tutorial/css/featherlight.min.css?1719308635 rel=stylesheet><link href=/kubernetes-tutorial/css/perfect-scrollbar.min.css?1719308635 rel=stylesheet><link href=/kubernetes-tutorial/css/auto-complete.css?1719308635 rel=stylesheet><link href=/kubernetes-tutorial/css/atom-one-dark-reasonable.css?1719308635 rel=stylesheet><link href=/kubernetes-tutorial/css/theme.css?1719308635 rel=stylesheet><link href=/kubernetes-tutorial/css/tabs.css?1719308635 rel=stylesheet><link href=/kubernetes-tutorial/css/hugo-theme.css?1719308635 rel=stylesheet><link href=/kubernetes-tutorial/css/theme-blue.css?1719308635 rel=stylesheet><script src=/kubernetes-tutorial/js/jquery-3.3.1.min.js?1719308635></script><style>:root #header+#content>#left>#rlblock_left{display:none!important}</style></head><body data-url=/kubernetes-tutorial/kubernetes/intermediare/volumes/><nav id=sidebar class=showVisitedLinks><div id=header-wrapper><div id=header><img src=../../../../kubernetes-tutorial/media/logo.png></div><div class=searchbox><label for=search-by><i class="fas fa-search"></i></label>
<input data-search-input id=search-by type=search placeholder=Search...>
<span data-search-clear><i class="fas fa-times"></i></span></div><script type=text/javascript src=/kubernetes-tutorial/js/lunr.min.js?1719308635></script><script type=text/javascript src=/kubernetes-tutorial/js/auto-complete.js?1719308635></script><script type=text/javascript>var baseurl="https://maxime-cls.github.io/kubernetes-tutorial/"</script><script type=text/javascript src=/kubernetes-tutorial/js/search.js?1719308635></script></div><div class=highlightable><ul class=topics><li data-nav-id=/kubernetes-tutorial/kubernetes/ title=Kubernetes class="dd-item
parent"><a href=/kubernetes-tutorial/kubernetes/>Kubernetes
<i class="fas fa-check read-icon"></i></a><ul><li data-nav-id=/kubernetes-tutorial/kubernetes/d%C3%A9butant/ title=Débutant class=dd-item><a href=/kubernetes-tutorial/kubernetes/d%C3%A9butant/>Débutant
<i class="fas fa-check read-icon"></i></a><ul><li data-nav-id=/kubernetes-tutorial/kubernetes/d%C3%A9butant/kubectl/ title=Kubectl class=dd-item><a href=/kubernetes-tutorial/kubernetes/d%C3%A9butant/kubectl/>Kubectl
<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/kubernetes-tutorial/kubernetes/d%C3%A9butant/pod-replica-deployment/ title="Pod, Replicaset, Deployment" class=dd-item><a href=/kubernetes-tutorial/kubernetes/d%C3%A9butant/pod-replica-deployment/>Pod, Replicaset, Deployment
<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/kubernetes-tutorial/kubernetes/d%C3%A9butant/services/ title=Service class=dd-item><a href=/kubernetes-tutorial/kubernetes/d%C3%A9butant/services/>Service
<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/kubernetes-tutorial/kubernetes/d%C3%A9butant/logs/ title=Logs class=dd-item><a href=/kubernetes-tutorial/kubernetes/d%C3%A9butant/logs/>Logs
<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/kubernetes-tutorial/kubernetes/d%C3%A9butant/servicemagic/ title="Service Magic" class=dd-item><a href=/kubernetes-tutorial/kubernetes/d%C3%A9butant/servicemagic/>Service Magic
<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/kubernetes-tutorial/kubernetes/d%C3%A9butant/blue-green/ title="Déploiement Blue/Green" class=dd-item><a href=/kubernetes-tutorial/kubernetes/d%C3%A9butant/blue-green/>Déploiement Blue/Green
<i class="fas fa-check read-icon"></i></a></li></ul></li><li data-nav-id=/kubernetes-tutorial/kubernetes/%C3%A9l%C3%A9mentaire/ title=Elementaire class=dd-item><a href=/kubernetes-tutorial/kubernetes/%C3%A9l%C3%A9mentaire/>Elementaire
<i class="fas fa-check read-icon"></i></a><ul><li data-nav-id=/kubernetes-tutorial/kubernetes/%C3%A9l%C3%A9mentaire/ressources-limites/ title="Ressources et limites" class=dd-item><a href=/kubernetes-tutorial/kubernetes/%C3%A9l%C3%A9mentaire/ressources-limites/>Ressources et limites
<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/kubernetes-tutorial/kubernetes/%C3%A9l%C3%A9mentaire/mise-a-jour/ title="Mise à jour permanentes" class=dd-item><a href=/kubernetes-tutorial/kubernetes/%C3%A9l%C3%A9mentaire/mise-a-jour/>Mise à jour permanentes
<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/kubernetes-tutorial/kubernetes/%C3%A9l%C3%A9mentaire/liveness-readiness/ title="Liveness & Readiness" class=dd-item><a href=/kubernetes-tutorial/kubernetes/%C3%A9l%C3%A9mentaire/liveness-readiness/>Liveness & Readiness
<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/kubernetes-tutorial/kubernetes/%C3%A9l%C3%A9mentaire/configmap/ title=Configmap class=dd-item><a href=/kubernetes-tutorial/kubernetes/%C3%A9l%C3%A9mentaire/configmap/>Configmap
<i class="fas fa-check read-icon"></i></a></li></ul></li><li data-nav-id=/kubernetes-tutorial/kubernetes/intermediare/ title=Intermediare class="dd-item
parent"><a href=/kubernetes-tutorial/kubernetes/intermediare/>Intermediare
<i class="fas fa-check read-icon"></i></a><ul><li data-nav-id=/kubernetes-tutorial/kubernetes/intermediare/secret/ title=Secret class=dd-item><a href=/kubernetes-tutorial/kubernetes/intermediare/secret/>Secret
<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/kubernetes-tutorial/kubernetes/intermediare/operator/ title=Operator class=dd-item><a href=/kubernetes-tutorial/kubernetes/intermediare/operator/>Operator
<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/kubernetes-tutorial/kubernetes/intermediare/volumes/ title=Volumes class="dd-item active"><a href=/kubernetes-tutorial/kubernetes/intermediare/volumes/>Volumes
<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/kubernetes-tutorial/kubernetes/intermediare/taints_affinity/ title="Taints et Affinity" class=dd-item><a href=/kubernetes-tutorial/kubernetes/intermediare/taints_affinity/>Taints et Affinity
<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/kubernetes-tutorial/kubernetes/intermediare/job_cronjob/ title="Job & CronJob" class=dd-item><a href=/kubernetes-tutorial/kubernetes/intermediare/job_cronjob/>Job & CronJob
<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/kubernetes-tutorial/kubernetes/intermediare/daemonset/ title=Daemonset class=dd-item><a href=/kubernetes-tutorial/kubernetes/intermediare/daemonset/>Daemonset
<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/kubernetes-tutorial/kubernetes/intermediare/statefulsets/ title=StatefulSets class=dd-item><a href=/kubernetes-tutorial/kubernetes/intermediare/statefulsets/>StatefulSets
<i class="fas fa-check read-icon"></i></a></li></ul></li><li data-nav-id=/kubernetes-tutorial/kubernetes/avance/ title=Avancé class=dd-item><a href=/kubernetes-tutorial/kubernetes/avance/>Avancé
<i class="fas fa-check read-icon"></i></a><ul><li data-nav-id=/kubernetes-tutorial/kubernetes/avance/ingress/ title=Ingress class=dd-item><a href=/kubernetes-tutorial/kubernetes/avance/ingress/>Ingress
<i class="fas fa-check read-icon"></i></a></li></ul></li></ul></li></ul><section id=prefooter><hr><ul><li><a class=padding href=# data-clear-history-toggle><i class="fas fa-history fa-fw"></i> Clear History</a></li></ul></section><section id=footer><p>Built with <a href=https://github.com/matcornic/hugo-theme-learn><i class="fas fa-heart"></i></a> from <a href=https://getgrav.org>Grav</a> and <a href=https://gohugo.io/>Hugo</a></p></section></div></nav><section id=body><div id=overlay></div><div class="padding highlightable"><div><div id=top-bar><div id=breadcrumbs itemscope itemtype=http://data-vocabulary.org/Breadcrumb><span id=sidebar-toggle-span><a href=# id=sidebar-toggle data-sidebar-toggle><i class="fas fa-bars"></i>
</a></span><span id=toc-menu><i class="fas fa-list-alt"></i></span>
<span class=links><a href=/kubernetes-tutorial/>Kubernetes Tutoriel</a> > <a href=/kubernetes-tutorial/kubernetes/>Kubernetes</a> > <a href=/kubernetes-tutorial/kubernetes/intermediare/>Intermediare</a> > Volumes</span></div><div class=progress><div class=wrapper><nav id=TableOfContents><ul><li><a href=#prérequis>Prérequis</a></li><li><a href=#volumes>Volumes</a><ul><li></li></ul></li><li><a href=#hostpath>HostPath</a></li><li><a href=#persistent-volume--persistent-volume-claim>Persistent Volume & Persistent Volume Claim</a><ul><li></li></ul></li><li><a href=#provisonnement-statique-vs-dynamique>Provisonnement Statique vs Dynamique</a></li><li><a href=#systèmes-de-fichiers-distribués>Systèmes de fichiers distribués</a></li></ul></nav></div></div></div></div><div id=head-tags></div><div id=body-inner><h1>Volumes</h1><h2 id=prérequis>Prérequis</h2><ul><li>Minikube <a href=https://kubernetes.io/fr/docs/tasks/tools/install-minikube/#installez-minikube-par-t%C3%A9l%C3%A9chargement-direct>Install</a> <a href=https://kubernetes.io/docs/setup/learning-environment/minikube/#specifying-the-vm-driver>Driver none</a></li><li>kubectl <a href=https://kubernetes.io/fr/docs/tasks/tools/install-kubectl/>Install</a></li><li>Stern <a href=https://kubernetes.io/blog/2016/10/tail-kubernetes-with-stern/>Docs</a> <a href=https://github.com/wercker/stern/releases>Release</a></li><li>jq <a href=https://stedolan.github.io/jq/download/>Install</a></li><li>3 terminal SSH</li></ul><p>Les conteneurs sont éphémères par définition, ce qui signifie que tout ce qui est stocké au moment de l&rsquo;exécution est perdu lorsque le conteneur est arrêté. Cela peut poser des problèmes avec les conteneurs qui ont besoin de conserver leurs données, comme les conteneurs de base de données.</p><p>Un volume Kubernetes est simplement un répertoire accessible aux conteneurs d&rsquo;un pod. Le concept est similaire aux volumes Docker, mais dans Docker, vous faites correspondre le conteneur à un ordinateur hôte. Dans le cas des volumes Kubernetes, le support qui le soutient et son contenu sont déterminés par le type de volume particulier utilisé.</p><p>Certains de ces types de volumes sont :</p><ul><li>awsElasticBlockStore</li><li>azureDisk</li><li>cephfs</li><li>nfs</li><li>local</li><li>répertoire vide</li><li>chemin de l&rsquo;hôte</li></ul><p>Commençons par deux exemples de Volumes.</p><h2 id=volumes>Volumes</h2><h4 id=emptydir>EmptyDir</h4><p>Un volume emptyDir est créé pour la première fois lorsqu&rsquo;un Pod est affecté à un nœud et existe tant que ce Pod fonctionne sur ce nœud. Comme son nom l&rsquo;indique, il est initialement vide. Tous les conteneurs d&rsquo;un même pod peuvent lire et écrire dans le même volume emptyDir. Lorsqu&rsquo;un Pod est redémarré ou supprimé, les données contenues dans le volume &ldquo;emptyDir&rdquo; sont perdues à jamais.</p><p>Déployons un service qui expose deux points de terminaison, l&rsquo;un pour écrire du contenu dans un fichier et l&rsquo;autre pour récupérer le contenu de ce fichier.</p><pre tabindex=0><code>vim apps/kubefiles/myboot-pod-volume.yml
</code></pre><pre tabindex=0><code>apiVersion: v1
kind: Pod
metadata:
  name: myboot-demo
spec:
  containers:
  - name: myboot-demo
    image: quay.io/rhdevelopers/myboot:v4

    volumeMounts:
    - mountPath: /tmp/demo
      name: demo-volume

  volumes:
  - name: demo-volume
    emptyDir: {}
</code></pre><p>Dans la section volumes, vous définissez le volume, et dans la section volumeMounts, comment le volume est monté à l&rsquo;intérieur du conteneur.</p><pre tabindex=0><code>kubectl apply -f apps/kubefiles/myboot-pod-volume.yml

kubectl get pods
</code></pre><pre tabindex=0><code>NAME          READY   STATUS    RESTARTS   AGE
myboot-demo   1/1     Running   0          83s
</code></pre><p>Accédons au conteneur et exécutons ces méthodes :</p><pre tabindex=0><code>kubectl exec -ti myboot-demo /bin/bash

curl localhost:8080/appendgreetingfile
curl localhost:8080/readgreetingfile
</code></pre><pre tabindex=0><code>Jambo
</code></pre><p>Dans ce cas, le emptyDir a été défini à /tmp/demo, vous pouvez donc vérifier le contenu du répertoire en exécutant ls :</p><pre tabindex=0><code>ls /tmp/demo
</code></pre><pre tabindex=0><code>greeting.txt
</code></pre><p>Quitter le shell du conteneur :</p><pre tabindex=0><code>exit
</code></pre><p>Et supprimez le pod.</p><pre tabindex=0><code>kubectl delete pod myboot-demo
</code></pre><p>Ensuite, si vous déployez à nouveau le même service, vous remarquerez que le contenu du répertoire est vide.</p><pre tabindex=0><code>kubectl exec -ti myboot-demo /bin/bash

ls /tmp/demo
exit
</code></pre><p>Et supprimez le pod.</p><pre tabindex=0><code>kubectl delete pod myboot-demo
</code></pre><p>emptyDir est partagé entre les conteneurs d&rsquo;un même Pod. Le déploiement suivant crée un pod avec deux conteneurs montant le même volume :</p><pre tabindex=0><code>vim apps/kubefiles/myboot-pods-volume.yml
</code></pre><pre tabindex=0><code>apiVersion: v1
kind: Pod
metadata:
  name: myboot-demo
spec:
  containers:
  - name: myboot-demo-1 #&lt;.&gt;
    image: quay.io/rhdevelopers/myboot:v4
    volumeMounts:
    - mountPath: /tmp/demo
      name: demo-volume

  - name: myboot-demo-2 #&lt;.&gt;
    image: quay.io/rhdevelopers/myboot:v4 #&lt;.&gt;

    env:
    - name: SERVER_PORT #&lt;.&gt;
      value: &#34;8090&#34;

    volumeMounts:
    - mountPath: /tmp/demo
      name: demo-volume

  volumes:
  - name: demo-volume #&lt;.&gt;
    emptyDir: {}
</code></pre><pre tabindex=0><code>kubectl apply -f apps/kubefiles/myboot-pods-volume.yml

kubectl get pods
</code></pre><pre tabindex=0><code>NAME          READY   STATUS    RESTARTS   AGE
myboot-demo   2/2     Running   0          4s
</code></pre><p>Accédons au premier conteneur et générons du contenu dans le répertoire /tmp/demo.</p><pre tabindex=0><code>kubectl exec -ti myboot-demo -c myboot-demo-1 /bin/bash

curl localhost:8080/appendgreetingfile

exit
</code></pre><p>Et lire le contenu du fichier dans l&rsquo;autre conteneur :</p><pre tabindex=0><code>kubectl exec myboot-demo -c myboot-demo-2 &#34;cat /tmp/demo/greeting.txt&#34;
</code></pre><pre tabindex=0><code>Jambo
</code></pre><p>Vous pouvez obtenir les informations sur le volume d&rsquo;un Pod en exécutant :</p><pre tabindex=0><code>kubectl describe pod myboot-demo
</code></pre><pre tabindex=0><code>Volumes:
  demo-volume:
    Type:       EmptyDir (a temporary directory that shares a pods lifetime)
    Medium:
    SizeLimit:  &lt;unset&gt;
</code></pre><p>Supprimer les ressources</p><pre tabindex=0><code>kubectl delete -f apps/kubefiles/myboot-pods-volume.yml
</code></pre><h2 id=hostpath>HostPath</h2><p>Un volume hostPath monte un fichier ou un répertoire du système de fichiers du nœud dans le Pod.</p><pre tabindex=0><code>vim apps/kubefiles/myboot-pod-volume-hostpath.yaml
</code></pre><pre tabindex=0><code>apiVersion: v1
kind: Pod
metadata:
  name: myboot-demo
spec:
  containers:
  - name: myboot-demo
    image: quay.io/rhdevelopers/myboot:v4

    volumeMounts:
    - mountPath: /tmp/demo
      name: demo-volume

  volumes:
  - name: demo-volume
    hostPath:
      path: &#34;/mnt/data&#34;
</code></pre><p>Dans ce cas, vous définissez le répertoire de l&rsquo;hôte/nœud où le contenu sera stocké.</p><pre tabindex=0><code>kubectl apply -f apps/kubefiles/myboot-pod-volume-hostpath.yaml
</code></pre><p>Maintenant, si vous décrivez le Pod, dans la section des volumes, vous verrez :</p><pre tabindex=0><code>kubectl describe pod myboot-demo
</code></pre><pre tabindex=0><code>Volumes:
  demo-volume:
    Type:          HostPath (bare host directory volume)
    Path:          /mnt/data
    HostPathType:
</code></pre><p>Notez que maintenant le contenu stocké dans /tmp/demo à l&rsquo;intérieur du Pod est stocké dans le chemin de l&rsquo;hôte /mnt/data, donc si le Pod meurt, le contenu n&rsquo;est pas perdu. Mais cela ne résout pas tous les problèmes car si le Pod tombe en panne et qu&rsquo;il est reprogrammé dans un autre nœud, les données ne seront pas dans cet autre nœud.</p><p>Voyons un autre exemple, dans ce cas pour un volume Amazon EBS :</p><pre tabindex=0><code>apiVersion: v1
kind: Pod
metadata:
  name: test-ebs
spec:
...
  volumes:
    - name: test-volume
      awsElasticBlockStore:
        volumeID: &lt;volume-id&gt;
        fsType: ext4
</code></pre><p>Ce que nous voulons que vous remarquiez dans l&rsquo;extrait précédent, c&rsquo;est que vous mélangez des éléments de votre application (c&rsquo;est-à-dire le conteneur, les sondes, les ports, &mldr;) qui sont plus du côté du développement avec des éléments plus liés au cloud (c&rsquo;est-à-dire le stockage physique), qui est plus du côté des opérations.</p><p>Pour éviter ce mélange de concepts, Kubernetes offre une certaine couche d&rsquo;abstractions, de sorte que les développeurs demandent simplement de l&rsquo;espace pour stocker les données (-persistent volume claim_), et l&rsquo;équipe des opérations offre la configuration du stockage physique.</p><p>Supprimer les ressources</p><pre tabindex=0><code>kubectl delete pod myboot-demo
</code></pre><h2 id=persistent-volume--persistent-volume-claim>Persistent Volume & Persistent Volume Claim</h2><p>Un PersistentVolume (PV) est une ressource Kubernetes qui est créée par un administrateur ou dynamiquement à l&rsquo;aide de Storage Classes indépendamment de Pod. Il capture les détails de l&rsquo;implémentation du stockage, il peut s&rsquo;agir de NFS, Ceph, iSCSI, ou d&rsquo;un système de stockage spécifique au fournisseur de cloud.</p><p>Une PersistentVolumeClaim (PVC) est une demande de stockage par un utilisateur. Il peut demander une taille de volume spécifique ou, par exemple, le mode d&rsquo;accès.</p><h4 id=volume-persistantclaim-avec-hostpath>Volume persistant/claim avec hostPath</h4><p>Utilisons la stratégie hostPath sans la configurer directement en tant que volume, mais en utilisant le volume persistant et la réclamation de volume persistant.</p><pre tabindex=0><code>vim apps/kubefiles/demo-persistent-volume-hostpath.yaml
</code></pre><pre tabindex=0><code>kind: PersistentVolume
apiVersion: v1
metadata:
  name: my-persistent-volume
  labels:
    type: local
spec:
  storageClassName: pv-demo
  capacity:
    storage: 100Mi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: &#34;/mnt/persistent-volume&#34;
</code></pre><p>Désormais, les informations relatives au volume ne se trouvent plus dans le pod mais dans l&rsquo;objet volume persistant.</p><pre tabindex=0><code>kubectl apply -f apps/kubefiles/demo-persistent-volume-hostpath.yaml

kubectl get pv
</code></pre><pre tabindex=0><code>NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM                                           STORAGECLASS   REASON   AGE
my-persistent-volume                       100Mi      RWO            Retain           Available                                                   pv-demo                 5s
</code></pre><p>Ensuite, du côté du développeur, nous devons réclamer ce dont nous avons besoin sur le PV. Dans l&rsquo;exemple suivant, nous demandons un espace de 10Mi.</p><pre tabindex=0><code>vim apps/kubefiles/myboot-persistent-volume-claim.yaml
</code></pre><pre tabindex=0><code>kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: myboot-volumeclaim
spec:
  storageClassName: pv-demo
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Mi
</code></pre><pre tabindex=0><code>kubectl apply -f apps/kubefiles/myboot-persistent-volume-claim.yaml

kubectl get pvc
</code></pre><pre tabindex=0><code>NAME                 STATUS   VOLUME                 CAPACITY   ACCESS MODES   STORAGECLASS   AGE
myboot-volumeclaim   Bound    my-persistent-volume   100Mi      RWO            pv-demo        3s
</code></pre><p>La grande différence est que maintenant, dans le pod, vous définissez simplement dans la section volumes, non pas la configuration du volume directement, mais la revendication du volume persistant à utiliser.</p><pre tabindex=0><code>vim apps/kubefiles/myboot-pod-volume-pvc.yaml
</code></pre><pre tabindex=0><code>apiVersion: v1
kind: Pod
metadata:
  name: myboot-demo
spec:
  containers:
  - name: myboot-demo
    image: quay.io/rhdevelopers/myboot:v4

    volumeMounts:
    - mountPath: /tmp/demo
      name: demo-volume

  volumes:
  - name: demo-volume
    persistentVolumeClaim:
      claimName: myboot-volumeclaim
</code></pre><pre tabindex=0><code>kubectl apply -f apps/kubefiles/myboot-pod-volume-pvc.yaml

kubectl describe pod myboot-demo
</code></pre><pre tabindex=0><code>Volumes:
  demo-volume:
    Type:       PersistentVolumeClaim (a reference to a PersistentVolumeClaim in the same namespace)
    ClaimName:  myboot-volumeclaim
    ReadOnly:   false
</code></pre><p>Remarquez que maintenant la description du pod montre que le volume n&rsquo;est pas défini directement mais par le biais d&rsquo;une réclamation de volume de persistance.</p><pre tabindex=0><code>kubectl delete pod myboot-demo

kubectl get pvc
</code></pre><p>Même si le pod a été supprimé, le PVC (et le PV) sont toujours là et doivent être supprimés manuellement.</p><pre tabindex=0><code>NAME                 STATUS   VOLUME                 CAPACITY   ACCESS MODES   STORAGECLASS   AGE
myboot-volumeclaim   Bound    my-persistent-volume   100Mi      RWO            pv-demo        14m
</code></pre><p>Supprimer les ressources</p><pre tabindex=0><code>kubectl delete -f apps/kubefiles/myboot-persistent-volume-claim.yaml
kubectl delete -f apps/kubefiles/demo-persistent-volume-hostpath.yaml
</code></pre><h2 id=provisonnement-statique-vs-dynamique>Provisonnement Statique vs Dynamique</h2><p>Les Persistent Volumes peuvent être provisionnés de manière dynamique ou statique.</p><p>Le provisionnement statique permet aux administrateurs de clusters de mettre à disposition d&rsquo;un cluster une unité de stockage existante. Lorsqu&rsquo;il est effectué de cette manière, le PV et le PVC doivent être fournis manuellement.</p><p>Jusqu&rsquo;à présent, dans le dernier exemple, vous avez vu le provisionnement statique.</p><p>Avec le provisionnement dynamique, les administrateurs de clusters n&rsquo;ont plus besoin de pré-provisionner le stockage. Au lieu de cela, il provisionne automatiquement le stockage lorsqu&rsquo;il est demandé par les utilisateurs. Pour le faire fonctionner, vous devez fournir un objet Storage Class et un PVC s&rsquo;y référant. Une fois le PVC créé, le périphérique de stockage et le PV sont automatiquement créés pour vous. L&rsquo;objectif principal du provisionnement dynamique est de travailler avec des solutions de fournisseurs de cloud.</p><p>Normalement, l&rsquo;implémentation de Kubernetes propose une classe de stockage par défaut afin que chacun puisse démarrer rapidement avec le provisionnement dynamique. Vous pouvez obtenir des informations sur la classe de stockage par défaut en exécutant :</p><pre tabindex=0><code>kubectl get sc
</code></pre><pre tabindex=0><code>NAME                 PROVISIONER                RECLAIMPOLICY   VOLUMEBINDINGMODE   ALLOWVOLUMEEXPANSION   AGE
standard (default)   k8s.io/minikube-hostpath   Delete          Immediate           false                  47d
</code></pre><p>Ensuite, vous pouvez créer une réclamation de volume persistant qui créera automatiquement un volume persistant.</p><pre tabindex=0><code>vim apps/kubefiles/demo-dynamic-persistent.yaml
</code></pre><pre tabindex=0><code>kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: myboot-volumeclaim
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Mi
</code></pre><p>Puisque nous n&rsquo;avons pas spécifié de classe de stockage mais qu&rsquo;il y en a une définie par défaut, le PVC se réfère implicitement à celle-ci.</p><pre tabindex=0><code>kubectl apply -f apps/kubefiles/demo-dynamic-persistent.yaml

kubectl get pvc
</code></pre><pre tabindex=0><code>NAME                 STATUS    VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE
myboot-volumeclaim   Pending                                      gp2            46sç
</code></pre><p>Remarquez que le PVC est en état d&rsquo;attente, car rappelez-vous que nous créons un stockage dynamique et que cela signifie que tant que le pod ne demande pas le volume, le PVC restera en état d&rsquo;attente et le PV ne sera pas créé.</p><pre tabindex=0><code>kubectl apply -f apps/kubefiles/myboot-pod-volume-pvc.yaml

kubectl get pods
</code></pre><pre tabindex=0><code>NAME          READY   STATUS    RESTARTS   AGE
myboot-demo   1/1     Running   0          2m36s
</code></pre><p>Lorsque le pod est en état de fonctionnement, vous pouvez obtenir les paramètres PVC et PV.</p><pre tabindex=0><code>kubectl get pvc
</code></pre><pre tabindex=0><code>NAME                 STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE
myboot-volumeclaim   Bound    pvc-6de4f27e-bd40-4b58-bb46-91eb08ca5bd7   1Gi        RWO            gp2            116s
</code></pre><p>Remarquez que maintenant la demande de volume est liée à un volume.</p><p>Enfin, vous pouvez vérifier que le PV a été créé automatiquement :</p><p>kubectl get pv</p><pre tabindex=0><code>NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                        STORAGECLASS   REASON   AGE
pvc-6de4f27e-bd40-4b58-bb46-91eb08ca5bd7   1Gi        RWO            Delete           Bound    default/myboot-volumeclaim   gp2                     77s
</code></pre><p>Notez que le champ CLAIM pointe vers le PVC responsable de la création du PV.</p><p>Supprimer les ressources</p><pre tabindex=0><code>kubectl delete -f apps/kubefiles/myboot-pod-volume-pvc.yaml
kubectl delete -f apps/kubefiles/demo-dynamic-persistent.yaml
</code></pre><h2 id=systèmes-de-fichiers-distribués>Systèmes de fichiers distribués</h2><p>Il est important de noter que les fournisseurs de cloud computing proposent des stockages distribués afin que les données soient toujours disponibles dans tous les nœuds. Comme vous l&rsquo;avez vu dans le dernier exemple, cette classe de stockage garantit que tous les nœuds voient le même contenu de disque.</p><p>Si par exemple, vous utilisez Kubernetes on-prem ou si vous ne voulez pas relayer vers une solution fournisseur, il existe également une prise en charge des systèmes de fichiers distribués dans Kubernetes. Si c&rsquo;est le cas, nous vous recommandons d&rsquo;utiliser NFS, GlusterFS ou Ceph.</p><footer class=footline></footer></div></div><div id=navigation><a class="nav nav-prev" href=/kubernetes-tutorial/kubernetes/intermediare/operator/ title=Operator><i class="fa fa-chevron-left"></i></a>
<a class="nav nav-next" href=/kubernetes-tutorial/kubernetes/intermediare/taints_affinity/ title="Taints et Affinity" style=margin-right:0><i class="fa fa-chevron-right"></i></a></div></section><div style=left:-1000px;overflow:scroll;position:absolute;top:-1000px;border:none;box-sizing:content-box;height:200px;margin:0;padding:0;width:200px><div style=border:none;box-sizing:content-box;height:200px;margin:0;padding:0;width:200px></div></div><script src=/kubernetes-tutorial/js/clipboard.min.js?1719308635></script><script src=/kubernetes-tutorial/js/perfect-scrollbar.min.js?1719308635></script><script src=/kubernetes-tutorial/js/perfect-scrollbar.jquery.min.js?1719308635></script><script src=/kubernetes-tutorial/js/jquery.sticky.js?1719308635></script><script src=/kubernetes-tutorial/js/featherlight.min.js?1719308635></script><script src=/kubernetes-tutorial/js/highlight.pack.js?1719308635></script><script>hljs.initHighlightingOnLoad()</script><script src=/kubernetes-tutorial/js/modernizr.custom-3.6.0.js?1719308635></script><script src=/kubernetes-tutorial/js/learn.js?1719308635></script><script src=/kubernetes-tutorial/js/hugo-learn.js?1719308635></script><script src=/kubernetes-tutorial/mermaid/mermaid.js?1719308635></script><script>mermaid.initialize({startOnLoad:!0})</script></body></html>