[{"uri":"https://maxime-cls.github.io/kubernetes-tutorial/kubernetes/avance/ingress/","title":"Ingress","tags":[],"description":"","content":"Pr√©requis Minikube Install Driver none kubectl Install Stern Docs Release jq Install 3 terminal SSH Cette section ne fonctionne pas sur MacOs. Vous devez absolument √™tre sur une machine Linux.\nActiver le contr√¥leur d\u0026rsquo;entr√©e Si vous utilisez minikube, vous devez activer le contr√¥leur NGNIX Ingress.\nminikube addons enable ingress Attendez une minute ou deux et v√©rifiez qu\u0026rsquo;il a √©t√© d√©ploy√© correctement :\nkubectl get pods -n ingress-nginx ingress-nginx-admission-create-lqfh2 0/1 Completed 0 6m28s\ringress-nginx-admission-patch-z2lzj 0/1 Completed 2 6m28s\ringress-nginx-controller-69ccf5d9d8-95xgp 1/1 Running 0 6m28s D√©ployer l\u0026rsquo;application cat \u0026lt;\u0026lt;EOF | kubectl apply -f -\rapiVersion: apps/v1\rkind: Deployment\rmetadata:\rname: quarkus-demo-deployment\rspec:\rreplicas: 1\rselector:\rmatchLabels:\rapp: quarkus-demo\rtemplate:\rmetadata:\rlabels:\rapp: quarkus-demo\renv: dev\rspec:\rcontainers:\r- name: quarkus-demo\rimage: quay.io/rhdevelopers/quarkus-demo:v1\rimagePullPolicy: Always\rports:\r- containerPort: 8080\rEOF Exposez le service :\nkubectl expose deployment quarkus-demo-deployment --type=LoadBalancer --port=8080\rkubectl get service quarkus-demo-deployment NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE\rquarkus-demo-deployment NodePort 10.105.106.66 \u0026lt;none\u0026gt; 8080:30408/TCP 11s IP=$(kubectl get service myapp -o jsonpath=\u0026#34;{.status.loadBalancer.ingress[0].ip}\u0026#34;)\rPORT=$(kubectl get service myapp -o jsonpath=\u0026#34;{.spec.ports[*].port}\u0026#34;) R√©aliser une requete sur le service :\ncurl $IP:$PORT Configuration l\u0026rsquo;Ingress Une ressource d\u0026rsquo;entr√©e est d√©finie comme suit :\nvim apps/kubefiles/demo-ingress.yaml apiVersion: networking.k8s.io/v1\rkind: Ingress\rmetadata:\rname: example-ingress\rannotations:\rnginx.ingress.kubernetes.io/rewrite-target: /$1\rspec:\rrules:\r- host: kube-team.info\rhttp:\rpaths:\r- path: /\rpathType: Prefix\rbackend:\rservice:\rname: quarkus-demo-deployment\rport:\rnumber: 8080 kubectl apply -f apps/kubefiles/demo-ingress.yaml Obtenir les informations de la ressource Ingress :\nkubectl get ingress NAME CLASS HOSTS ADDRESS PORTS AGE\rexample-ingress \u0026lt;none\u0026gt; kube-team.info 192.168.99.115 80 68s Vous devez attendre que le champ d\u0026rsquo;adresse soit d√©fini. Cela peut prendre quelques minutes.\nModifiez le fichier /etc/hosts pour faire pointer le nom d\u0026rsquo;h√¥te vers l\u0026rsquo;adresse Ingress.\nminikube ip 10.240.145.124 sudo vim /etc/hosts 10.240.145.124 kube-team.info curl kube-team.info Si vous avez un proxy :\ncurl --noproxy kube-team.info kube-team.info Supersonic Subatomic Java with Quarkus quarkus-demo-deployment-8cf45f5c8-qmzwl:1 Deuxi√®me d√©ploiement D√©ployer une deuxi√®me version du service :\ncat \u0026lt;\u0026lt;EOF | kubectl apply -f -\rapiVersion: apps/v1\rkind: Deployment\rmetadata:\rname: mynode-deployment\rspec:\rreplicas: 1\rselector:\rmatchLabels:\rapp: mynode\rtemplate:\rmetadata:\rlabels:\rapp: mynode\rspec:\rcontainers:\r- name: mynode\rimage: quay.io/rhdevelopers/mynode:v1\rports:\r- containerPort: 8000\rEOF kubectl expose deployment mynode-deployment --type=NodePort --port=8000 Mise √† jour de l\u0026rsquo;Ingress Ensuite, vous devez mettre √† jour la ressource Ingress avec le nouveau chemin :\nvim apps/kubefiles/demo-ingress-2.yaml apiVersion: networking.k8s.io/v1beta1\rkind: Ingress\rmetadata:\rname: example-ingress\rannotations:\rnginx.ingress.kubernetes.io/rewrite-target: /$1\rspec:\rrules:\r- host: kube-team.info\rhttp:\rpaths:\r- path: /\rbackend:\rserviceName: quarkus-demo-deployment\rservicePort: 8080\r- path: /v2\rbackend:\rserviceName: mynode-deployment\rservicePort: 8000 kubectl apply -f apps/kubefiles/demo-ingress-2.yaml Tester :\ncurl kube-team.info Supersonic Subatomic Java with Quarkus quarkus-demo-deployment-8cf45f5c8-qmzwl:2 curl kube-team.info/v2 Node Bonjour on mynode-deployment-77c7bf857d-5nfl4 0 Supprimer les ressources\nkubectl delete deployment mynode-deployment\rkubectl delete service mynode-deployment\rkubectl delete deployment quarkus-demo-deployment\rkubectl delete service quarkus-demo-deployment\rkubectl delete -f apps/kubefiles/demo-ingress-2.yaml "},{"uri":"https://maxime-cls.github.io/kubernetes-tutorial/kubernetes/d%C3%A9butant/kubectl/","title":"Kubectl","tags":[],"description":"","content":"Pr√©requis Une machine Linux Ubuntu ou Debian 8 CPU, 16GB RAM, 100GB Disk Minikube Install kubectl Install Stern Docs Release jq Install 3 terminal SSH Installation de minikube Linux mkdir bin \u0026amp;\u0026amp; cd bin\rcurl -Lo minikube https://storage.googleapis.com/minikube/releases/v1.29.0/minikube-linux-amd64\rchmod +x minikube\rcurl -LO https://storage.googleapis.com/kubernetes-release/release/v1.26.1/bin/linux/amd64/kubectl\rchmod +x kubectl\rcd .. MacOs mkdir bin \u0026amp;\u0026amp; cd bin\rcurl -Lo minikube https://storage.googleapis.com/minikube/releases/v1.29.0/minikube-darwin-amd64\rchmod +x minikube\rcurl -LO https://storage.googleapis.com/kubernetes-release/release/v1.26.1/bin/darwin/amd64/kubectl\rchmod +x kubectl\rcd .. Et ajouter les variables d\u0026rsquo;environnement :\nexport MINIKUBE_HOME=$(pwd);\rexport PATH=$MINIKUBE_HOME/bin:$PATH\rexport KUBECONFIG=$MINIKUBE_HOME/.kube/config\rexport KUBE_EDITOR=\u0026#34;code -w\u0026#34; Conserver les param√®tres de Vim dans .vimrc\nNous examinons les param√®tres importants de Vim si vous souhaitez travailler avec YAML pendant le TP K8s.\nParam√®tres\nCr√©ez d\u0026rsquo;abord ou ouvrez (s\u0026rsquo;il existe d√©j√†) le fichier .vimrc :\nvim ~/.vimrc Saisissez ensuite (en mode insertion activ√© avec i) les lignes suivantes :\nalias k=kubectl Sauvegardez et fermez le fichier en appuyant sur Esc suivi de :x et Enter.\nD√©marrer le cluster Kubernetes Linux minikube start --memory=8192 --cpus=3 --kubernetes-version=v1.26.1 --vm-driver=docker Avec un proxy :\nminikube start --memory=8192 --cpus=3 --docker-env HTTPS_PROXY=$HTTPS_PROXY --docker-env HTTP_PROXY=$HTTP_PROXY --docker-env=NO_PROXY=$NO_PROXY --kubernetes-version=v1.26.1 --vm-driver=docker MacOs minikube start --memory=8192 --cpus=3 --kubernetes-version=v1.26.1 --vm-driver=docker Avec un proxy :\nminikube start --memory=8192 --cpus=3 --docker-env HTTPS_PROXY=$HTTPS_PROXY --docker-env HTTP_PROXY=$HTTP_PROXY --docker-env=NO_PROXY=$NO_PROXY --kubernetes-version=v1.26.1 --vm-driver=docker Et le r√©sultat doit √™tre quelque chose de similaire :\nüòÑ [devnation] minikube v1.20.0 on Darwin 11.3\r‚úÖ Created a new profile : devnation\r‚úÖ minikube profile was successfully set to devnation\rüòÑ [default] minikube v1.29.0 on Darwin 11.3\r‚ú® Selecting \u0026#39;virtualbox\u0026#39; driver from user configuration (alternates: [hyperkit])\rüî• Creating virtualbox VM (CPUs=2, Memory=8192MB, Disk=50000MB) ...\rüê≥ Preparing Kubernetes v1.26.1 on Docker \u0026#39;20.10.6\u0026#39; ...\r‚ñ™ apiserver.enable-admission-plugins=LimitRanger,NamespaceExists,NamespaceLifecycle,ResourceQuota,ServiceAccount,DefaultStorageClass,MutatingAdmissionWebhook\rüöú Pulling images ...\rüöÄ Launching Kubernetes ...\r‚åõ Waiting for cluster to come online ...\rüèÑ Done! kubectl is now configured to use \u0026#34;devnation\u0026#34; Enfin, configurez l\u0026rsquo;utilisation de minikube internal docker comme docker host :\neval $(minikube docker-env) Installation de l\u0026rsquo;ingress controller minikube addons enable ingress V√©rifier que l\u0026rsquo;ingress controller est bien install√© :\nkubectl get pods -n ingress-nginx R√©sultat :\nNAME READY STATUS RESTARTS AGE\ringress-nginx-admission-create-g9g49 0/1 Completed 0 11m\ringress-nginx-admission-patch-rqp78 0/1 Completed 1 11m\ringress-nginx-controller-59b45fb494-26npt 1/1 Running 0 11m Parlez √† votre Cluster echo $KUBECONFIG\rkubectl config view Affiche les param√®tres fusionn√©s de kubeconfig\nVue du noeud kubectl get nodes\rkubectl get nodes --show-labels\rkubectl get namespaces Affiche tous les noeuds, les labels d√©finit et les espaces de noms.\nVoir les Pods pr√™ts √† l\u0026rsquo;emploi Votre fournisseur de Kubernetes comprend probablement de nombreuses espaces de noms pr√™tes √† l\u0026rsquo;emploi :\nkubectl get pods --all-namespaces\rkubectl get pods --all-namespaces --show-labels\rkubectl get pods --all-namespaces -o wide Affiche tous les espaces de noms, les labels d√©finit et les sorties. Les espaces de noms sont destin√©s √† √™tre utilis√©s dans des environnements avec de nombreux utilisateurs r√©partis sur plusieurs √©quipes ou projets. Les espaces de noms sont un moyen de diviser les ressources du cluster entre plusieurs utilisateurs\nD√©ployer quelque chose Cr√©er un espace de nommage et d√©ployer quelque chose :\nkubectl create namespace mystuff\rkubectl config set-context --current --namespace=mystuff\rkubectl create deployment myapp --image=quay.io/rhdevelopers/quarkus-demo:v1 La commande \u0026ldquo;kubectl config set-context\u0026rdquo; permet une bascule rapide entre les namespaces du cluster kubernetes.\nTout en surveillant les √©v√©nements terminal 2\nwatch kubectl get events --sort-by=.metadata.creationTimestamp LAST SEEN TYPE REASON OBJECT MESSAGE\r\u0026lt;unknown\u0026gt; Normal Scheduled pod/myapp-5dcbf46dfc-ghrk4 Successfully assigned mystuff/myapp-5dcbf46dfc-ghrk4 to g\rcp-5xldg-w-a-5ptpn.us-central1-a.c.ocp42project.internal\r29s Normal SuccessfulCreate replicaset/myapp-5dcbf46dfc Created pod: myapp-5dcbf46dfc-ghrk4\r29s Normal ScalingReplicaSet deployment/myapp Scaled up replica set myapp-5dcbf46dfc to 1\r21s Normal Pulling pod/myapp-5dcbf46dfc-ghrk4 Pulling image \u0026#34;quay.io/burrsutter/quarkus-demo:1.0.0\u0026#34;\r15s Normal Pulled pod/myapp-5dcbf46dfc-ghrk4 Successfully pulled image \u0026#34;quay.io/burrsutter/quarkus-dem\ro:1.0.0\u0026#34;\r15s Normal Created pod/myapp-5dcbf46dfc-ghrk4 Created container quarkus-demo\r15s Normal Started pod/myapp-5dcbf46dfc-ghrk4 Started container quarkus-demo La commande \u0026ldquo;watch\u0026rdquo; permet d\u0026rsquo;initer une √©coute en temps r√©el des modifications d\u0026rsquo;un objet.\nObjets cr√©√©s D√©ploiements\nkubectl get deployments NAME READY UP-TO-DATE AVAILABLE AGE\rmyapp 1/1 1 1 95s La sortie observer permet de connaitre l\u0026rsquo;√©tat du d√©ploiment d\u0026rsquo;un ou plusieurs pods. Le d√©ploiement fournit des mises √† jour d√©claratives pour Pods et ReplicaSets. Il permet de d√©crire l\u0026rsquo;√©tat d√©sir√© et le controlleur du d√©ploiement change l\u0026rsquo;√©tat r√©el √† l\u0026rsquo;√©tat souhait√©.\nReplicasets\nkubectl get replicasets NAME DESIRED CURRENT READY AGE\rmyapp-5dcbf46dfc 1 1 1 2m1s La sortie observer permet de connaitre l\u0026rsquo;√©tat d\u0026rsquo;un ensemble stable de Pods √† un moment donn√©. Cet objet est souvent utilis√© pour garantir la disponibilit√© d\u0026rsquo;un certain nombre identique de Pods.\nPods\nkubectl get pods --show-labels NAME READY STATUS RESTARTS AGE LABELS\rmyapp-5dcbf46dfc-ghrk4 1/1 Running 0 2m18s app=myapp,pod-template-hash=5dcbf46dfc La sortie observer permet de connaitre l\u0026rsquo;√©tat du pod. Les Pods sont les plus petites unit√©s informatiques d√©ployables qui peuvent √™tre cr√©√©es et g√©r√©es dans Kubernetes.\nUn pod (terme anglo-saxon d√©crivant un groupe de baleines ou une gousse de pois) est un groupe d\u0026rsquo;un ou plusieurs conteneurs (comme des conteneurs Docker), ayant du stockage/r√©seau partag√©, et une sp√©cification sur la mani√®re d\u0026rsquo;ex√©cuter ces conteneurs. Les √©l√©ments d\u0026rsquo;un pod sont toujours co-localis√©s et co-ordonnanc√©s, et s\u0026rsquo;ex√©cutent dans un contexte partag√©. Un pod mod√©lise un \u0026ldquo;h√¥te logique\u0026rdquo; sp√©cifique √† une application - il contient un ou plusieurs conteneurs applicatifs qui sont √©troitement li√©s ‚Äî dans un monde pr√©-conteneurs, √™tre ex√©cut√© sur la m√™me machine physique ou virtuelle signifierait √™tre ex√©cut√© sur le m√™me h√¥te logique.\nLogs\nkubectl logs -l app=myapp 2020-03-22 14:41:30,497 INFO [io.quarkus] (main) Quarkus 0.22.0 started in 0.021s. Listening on: http://0.0.0.0:8080\r2020-03-22 14:41:30,497 INFO [io.quarkus] (main) Installed features: [cdi, resteasy] Exposer un service kubectl expose deployment myapp --port=8080 --type=LoadBalancer terminal 2\nwatch kubectl get services NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE\rmyapp LoadBalancer 172.30.103.41 \u0026lt;pending\u0026gt; 8080:31974/TCP 4s Kubernetes ServiceTypesvous permet de sp√©cifier le type de service que vous souhaitez. La valeur par d√©faut est ClusterIP.\nType les valeurs et leurs comportements sont:\nClusterIP: Expose le service sur une IP interne au cluster. Le choix de cette valeur rend le service uniquement accessible √† partir du cluster. C\u0026rsquo;est la valeur par d√©faut ServiceType.\nNodePort: Expose le service sur l\u0026rsquo;IP de chaque n≈ìud √† un port statique (le NodePort). Un ClusterIPservice, vers lequel le NodePortservice est achemin√©, est automatiquement cr√©√©. Vous pourrez contacter le NodePortService, depuis l\u0026rsquo;ext√©rieur du cluster, en faisant la demande :.\nLoadBalancer: Expose le service en externe √† l\u0026rsquo;aide de l\u0026rsquo;√©quilibreur de charge d\u0026rsquo;un fournisseur de cloud. NodePortet les ClusterIPservices, vers lesquels les itin√©raires de l\u0026rsquo;√©quilibreur de charge externe, sont automatiquement cr√©√©s.\nExternalName: Mappe le service au contenu du externalNamechamp (par exemple foo.bar.example.com), en renvoyant un CNAME enregistrement avec sa valeur. Aucun mandataire d\u0026rsquo;aucune sorte n\u0026rsquo;est mis en place.\nParler aux applications terminal 3\nsudo minikube tunnel terminal 1\nIP=$(kubectl get service myapp -o jsonpath=\u0026#34;{.status.loadBalancer.ingress[0].ip}\u0026#34;)\rPORT=$(kubectl get service myapp -o jsonpath=\u0026#34;{.spec.ports[*].port}\u0026#34;) Sondez le r√©sultat :\nwhile true\rdo curl $IP:$PORT\rsleep .3\rdone R√©sultats du sondage :\nSupersonic Subatomic Java with Quarkus myapp-5dcbf46dfc-ghrk4:289\rSupersonic Subatomic Java with Quarkus myapp-5dcbf46dfc-ghrk4:290\rSupersonic Subatomic Java with Quarkus myapp-5dcbf46dfc-ghrk4:291\rSupersonic Subatomic Java with Quarkus myapp-5dcbf46dfc-ghrk4:292\rSupersonic Subatomic Java with Quarkus myapp-5dcbf46dfc-ghrk4:293 Terminal 3 Changer les r√©pliques :\nkubectl scale deployment myapp --replicas=3 NAME READY STATUS RESTARTS AGE\rmyapp-5dcbf46dfc-6sn2s 0/1 ContainerCreating 0 4s\rmyapp-5dcbf46dfc-ghrk4 1/1 Running 0 5m32s\rmyapp-5dcbf46dfc-z6hqw 0/1 ContainerCreating 0 4s Commencez une mise √† jour continue en changeant l\u0026rsquo;image :\nkubectl set image deployment/myapp quarkus-demo=quay.io/rhdevelopers/myboot:v1 Supersonic Subatomic Java with Quarkus myapp-5dcbf46dfc-6sn2s:188\rSupersonic Subatomic Java with Quarkus myapp-5dcbf46dfc-z6hqw:169\rAloha from Spring Boot! 0 on myapp-58b97dbd95-vxd87\rAloha from Spring Boot! 1 on myapp-58b97dbd95-vxd87\rSupersonic Subatomic Java with Quarkus myapp-5dcbf46dfc-6sn2s:189\rSupersonic Subatomic Java with Quarkus myapp-5dcbf46dfc-z6hqw:170\rAloha from Spring Boot! 2 on myapp-58b97dbd95-vxd87 kubectl set image deployment/myapp quarkus-demo=quay.io/rhdevelopers/myboot:v2 Bonjour from Spring Boot! 2 on myapp-7d58855c6b-6c8gd\rBonjour from Spring Boot! 3 on myapp-7d58855c6b-6c8gd\rAloha from Spring Boot! 7 on myapp-58b97dbd95-mjlwx\rBonjour from Spring Boot! 4 on myapp-7d58855c6b-6c8gd\rAloha from Spring Boot! 8 on myapp-58b97dbd95-mjlwx\rBonjour from Spring Boot! 5 on myapp-7d58855c6b-6c8gd kubectl set image deployment/myapp quarkus-demo=quay.io/rhdevelopers/quarkus-demo:v1 Bonjour from Spring Boot! 14 on myapp-7d58855c6b-dw67s\rSupersonic Subatomic Java with Quarkus myapp-5dcbf46dfc-tcfwp:3\rSupersonic Subatomic Java with Quarkus myapp-5dcbf46dfc-tcfwp:4\rBonjour from Spring Boot! 15 on myapp-7d58855c6b-dw67s\rSupersonic Subatomic Java with Quarkus myapp-5dcbf46dfc-tcfwp:5\rBonjour from Spring Boot! 13 on myapp-7d58855c6b-72wp8\rSupersonic Subatomic Java with Quarkus myapp-5dcbf46dfc-7rkxj:1\rSupersonic Subatomic Java with Quarkus myapp-5dcbf46dfc-7rkxj:2\rSupersonic Subatomic Java with Quarkus myapp-5dcbf46dfc-7lf9t:1\rSupersonic Subatomic Java with Quarkus myapp-5dcbf46dfc-7rkxj:3\rSupersonic Subatomic Java with Quarkus myapp-5dcbf46dfc-7lf9t:2\rSupersonic Subatomic Java with Quarkus myapp-5dcbf46dfc-7lf9t:3\rSupersonic Subatomic Java with Quarkus myapp-5dcbf46dfc-tcfwp:6 Nettoyage kubectl delete namespace mystuff\rkubectl config set-context --current --namespace=default "},{"uri":"https://maxime-cls.github.io/kubernetes-tutorial/kubernetes/%C3%A9l%C3%A9mentaire/ressources-limites/","title":"Ressources et limites","tags":[],"description":"","content":"Pr√©requis Minikube Install Driver none kubectl Install Stern Docs Release jq Install 3 terminal SSH Assurez-vous que vous √™tes dans le bon espace de noms :\nkubectl config set-context --current --namespace=myspace Assurez-vous que rien n\u0026rsquo;est en cours d\u0026rsquo;ex√©cution dans votre espace de nom :\nkubectl get all No resources found in myspace namespace. D√©ployez d\u0026rsquo;abord une application sans aucune Requ√™te ni Limite :\nCr√©er un fichier de d√©ploiement\nmkdir -p apps/kubefiles/\rvi apps/kubefiles/myboot-deployment.yml myboot-deployment.yml\napiVersion: apps/v1\rkind: Deployment\rmetadata:\rlabels:\rapp: myboot\rname: myboot\rspec:\rreplicas: 1\rselector:\rmatchLabels:\rapp: myboot\rtemplate:\rmetadata:\rlabels:\rapp: myboot\rspec:\rcontainers:\r- name: myboot\rimage: quay.io/rhdevelopers/myboot:v2\rports:\r- containerPort: 8080 D√©ployer la version 1 de l\u0026rsquo;applciation myboot\nkubectl apply -f apps/kubefiles/myboot-deployment.yml D√©crivez le pod :\nPODNAME=$(kubectl get pod -l app=myboot -o name)\rkubectl describe $PODNAME Il n\u0026rsquo;y a pas de limites de ressources configur√©es pour le pod.\nName: myboot-66d7d57687-jzbzj\rNamespace: myspace\rPriority: 0\rNode: gcp-5xldg-w-b-rlp45.us-central1-b.c.ocp42project.internal/10.0.32.5\rStart Time: Sun, 29 Mar 2020 14:24:24 -0400\rLabels: app=myboot\rpod-template-hash=66d7d57687\rAnnotations: k8s.v1.cni.cncf.io/networks-status:\r[{\r\u0026#34;name\u0026#34;: \u0026#34;openshift-sdn\u0026#34;,\r\u0026#34;interface\u0026#34;: \u0026#34;eth0\u0026#34;,\r\u0026#34;ips\u0026#34;: [\r\u0026#34;10.130.2.23\u0026#34;\r],\r\u0026#34;dns\u0026#34;: {},\r\u0026#34;default-route\u0026#34;: [\r\u0026#34;10.130.2.1\u0026#34;\r]\r}]\ropenshift.io/scc: restricted\rStatus: Running\rIP: 10.130.2.23\rIPs:\rIP: 10.130.2.23\rControlled By: ReplicaSet/myboot-66d7d57687\rContainers:\rmyboot:\rContainer ID: cri-o://2edfb0a5a93f375516ee49d33df20bee40c14792b37ec1648dc5205244095a53\rImage: quay.io/burrsutter/myboot:v1\rImage ID: quay.io/burrsutter/myboot@sha256:cdf39f191f5d322ebe6c04cae218b0ad8f6dbbb8a81e81a88c0fbc6e3c05f860\rPort: 8080/TCP\rHost Port: 0/TCP\rState: Running\rStarted: Sun, 29 Mar 2020 14:24:32 -0400\rReady: True\rRestart Count: 0\rEnvironment: \u0026lt;none\u0026gt;\rMounts:\r/var/run/secrets/kubernetes.io/serviceaccount from default-token-vlzsl (ro)\rConditions:\rType Status\rInitialized True\rReady True\rContainersReady True\rPodScheduled True\rVolumes:\rdefault-token-vlzsl:\rType: Secret (a volume populated by a Secret)\rSecretName: default-token-vlzsl\rOptional: false\rQoS Class: BestEffort\rNode-Selectors: \u0026lt;none\u0026gt;\rTolerations: node.kubernetes.io/not-ready:NoExecute for 300s\rnode.kubernetes.io/unreachable:NoExecute for 300s\rEvents:\rType Reason Age From Message\r---- ------ ---- ---- -------\rNormal Scheduled \u0026lt;unknown\u0026gt; default-scheduler Successfully assigned myspace/myboot-66d7d57687-jzbzj to gcp-5xldg-w-b-rlp45.us-central1-b.c.ocp42project.internal\rNormal Pulled 12m kubelet, gcp-5xldg-w-b-rlp45.us-central1-b.c.ocp42project.internal Container image \u0026#34;quay.io/burrsutter/myboot:v1\u0026#34; already present on machine\rNormal Created 12m kubelet, gcp-5xldg-w-b-rlp45.us-central1-b.c.ocp42project.internal Created container myboot\rNormal Started 12m kubelet, gcp-5xldg-w-b-rlp45.us-central1-b.c.ocp42project.internal Started container myboot Supprimez ce d√©ploiement :\nkubectl delete deployment myboot Cr√©ez un nouveau d√©ploiement avec des demandes de ressources :\nCr√©er un fichier de d√©ploiement\nvi apps/kubefiles/myboot-deployment-resources.yml myboot-deployment-resources.yml\napiVersion: apps/v1\rkind: Deployment\rmetadata:\rlabels:\rapp: myboot\rname: myboot\rspec:\rreplicas: 1\rselector:\rmatchLabels:\rapp: myboot\rtemplate:\rmetadata:\rlabels:\rapp: myboot\rspec:\rcontainers:\r- name: myboot\rimage: quay.io/rhdevelopers/myboot:v1\rports:\r- containerPort: 8080\rresources:\rrequests:\rmemory: \u0026#34;300Mi\u0026#34;\rcpu: \u0026#34;10000m\u0026#34; # 10 cores kubectl apply -f apps/kubefiles/myboot-deployment-resources.yml Et v√©rifiez le statut du Pod :\nkubectl get pods NAME READY STATUS RESTARTS AGE\rmyboot-7b7d754c86-kjwlr 0/1 Pending 0 19s Si vous voulez obtenir plus d\u0026rsquo;informations sur l\u0026rsquo;erreur :\nkubectl get events --sort-by=.metadata.creationTimestamp \u0026lt;unknown\u0026gt; Warning FailedScheduling pod/myboot-7b7d754c86-kjwlr 0/6 nodes are available: 6 Insufficient cpu.\r\u0026lt;unknown\u0026gt; Warning FailedScheduling pod/myboot-7b7d754c86-kjwlr 0/6 nodes are available: 6 Insufficient cpu. Les \u0026ldquo;demandes de ressources\u0026rdquo; de la sp√©cification du pod exigent qu\u0026rsquo;au moins un n≈ìud de travail ait N c≈ìurs et X m√©moires disponibles. Si aucun n≈ìud de travail ne r√©pond √† ces exigences, vous recevez le message \u0026ldquo;PENDING\u0026rdquo; et les notations appropri√©es dans la liste des √©v√©nements.\nVous pouvez √©galement utiliser kubectl describe sur le pod pour trouver plus d\u0026rsquo;informations sur l\u0026rsquo;√©chec.\nPODNAME=$(kubectl get pod -l app=myboot -o name)\rkubectl describe $PODNAME Supprimez le d√©ploiement :\nkubectl delete -f apps/kubefiles/myboot-deployment-resources.yml Cr√©ez un nouveau d√©ploiement avec une demande de ressources plus raisonnable et une limite stricte :\nCr√©er un fichier de d√©ploiement\nvi apps/kubefiles/myboot-deployment-resources-limits.yml myboot-deployment-resources-limits.yml\napiVersion: apps/v1\rkind: Deployment\rmetadata:\rlabels:\rapp: myboot\rname: myboot\rspec:\rreplicas: 1\rselector:\rmatchLabels:\rapp: myboot\rtemplate:\rmetadata:\rlabels:\rapp: myboot\rspec:\rcontainers:\r- name: myboot\rimage: quay.io/rhdevelopers/myboot:v1\rports:\r- containerPort: 8080\rresources:\rrequests:\rmemory: \u0026#34;300Mi\u0026#34;\rcpu: \u0026#34;250m\u0026#34; # 1/4 core\r# NOTE: These are the same limits we tested our Docker Container with earlier\r# -m matches limits.memory and --cpus matches limits.cpu\rlimits:\rmemory: \u0026#34;400Mi\u0026#34;\rcpu: \u0026#34;1000m\u0026#34; # 1 core kubectl apply -f apps/kubefiles/myboot-deployment-resources-limits.yml D√©crivez le Pod :\nPODNAME=$(kubectl get pod -l app=myboot -o name)\rkubectl describe $PODNAME D√©ployer le service :\nCr√©er un fichier pour votre service\nvi apps/kubefiles/myboot-service.yml myboot-service.yml\napiVersion: v1\rkind: Service\rmetadata:\rname: myboot\rlabels:\rapp: myboot\rspec:\rports:\r- name: http\rport: 8080\rselector:\rapp: myboot\rtype: LoadBalancer kubectl apply -f apps/kubefiles/myboot-service.yml Et surveillez votre Pod:\nwatch kubectl get pods Cr√©er les variables IP et Port\nIP=$(minikube ip)\rPORT=$(kubectl get service/myboot -o jsonpath=\u0026#34;{.spec.ports[*].nodePort}\u0026#34;) R√©aliser une requete sur le sevrice\ncurl $IP:$PORT Ex√©cuter une boucle\nwhile true\rdo curl $IP:$PORT\rsleep .3\rdone Dans une autre fen√™tre de terminal, curl le point de terminaison /sysresources\ncurl $IP:$PORT/sysresources PODNAME=$(kubectl get pod -l app=myboot -o name)\rkubectl get $PODNAME -o json | jq \u0026#34;.spec.containers[0].resources\u0026#34; {\r\u0026#34;limits\u0026#34;: {\r\u0026#34;cpu\u0026#34;: \u0026#34;1\u0026#34;,\r\u0026#34;memory\u0026#34;: \u0026#34;400Mi\u0026#34;\r},\r\u0026#34;requests\u0026#34;: {\r\u0026#34;cpu\u0026#34;: \u0026#34;250m\u0026#34;,\r\u0026#34;memory\u0026#34;: \u0026#34;300Mi\u0026#34;\r}\r} Puis curl le point de terminaison /consume :\ncurl $IP:$PORT/consume curl: (52) Empty reply from server Et vous devriez remarquer que votre boucle √©choue √©galement :\nAloha from Spring Boot! 1120 on myboot-d78fb6d58-69kl7\rcurl: (56) Recv failure: Connection reset by peer D√©crivez le Pod pour voir l\u0026rsquo;erreur :\nPODNAME=$(kubectl get pod -l app=myboot -o name)\rkubectl describe $PODNAME Et cherchez la partie suivante :\nLast State: Terminated\rReason: OOMKilled\rExit Code: 137 kubectl get $PODNAME -o json | jq \u0026#34;.status.containerStatuses[0].lastState.terminated\u0026#34; {\r\u0026#34;containerID\u0026#34;: \u0026#34;cri-o://7b9be70ce4b616d6083d528dee708cea879da967373dad0d396fb999bd3898d3\u0026#34;,\r\u0026#34;exitCode\u0026#34;: 137,\r\u0026#34;finishedAt\u0026#34;: \u0026#34;2020-03-29T19:14:56Z\u0026#34;,\r\u0026#34;reason\u0026#34;: \u0026#34;OOMKilled\u0026#34;,\r\u0026#34;startedAt\u0026#34;: \u0026#34;2020-03-29T18:50:15Z\u0026#34;\r} Vous pourriez m√™me voir la colonne STATUS avec watch kubectl get pods pour visualiser le OOMKilled :\nNAME READY STATUS RESTARTS AGE\rmyboot-d78fb6d58-69kl7 0/1 OOMKilled 1 30m Et vous remarquerez que la colonne RESTARTS s\u0026rsquo;incr√©mente √† chaque plantage du pod Spring Boot.\n"},{"uri":"https://maxime-cls.github.io/kubernetes-tutorial/kubernetes/intermediare/secret/","title":"Secret","tags":[],"description":"","content":"Pr√©requis Minikube Install Driver none kubectl Install Stern Docs Release jq Install 3 terminal SSH D√©ployer le service myboot :\nkubectl apply -f apps/kubefiles/myboot-deployment.yml D√©ployer le service myboot :\nkubectl apply -f apps/kubefiles/myboot-service.yml Regardez vos Pods:\nwatch kubectl get pods Regardez vos services:\nwatch kubectl get services NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE\rmyapp LoadBalancer 172.30.103.41 \u0026lt;pending\u0026gt; 8080:31974/TCP 4s Attendez jusqu\u0026rsquo;√† ce que vous voyez une IP externe assign√©e.\nNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE\rmyapp LoadBalancer 172.30.103.41 34.71.122.153 8080:31974/TCP 44s Cr√©er les variables IP et PORT :\nIP=$(minikube ip)\rPORT=$(kubectl get service/myboot -o jsonpath=\u0026#34;{.spec.ports[*].nodePort}\u0026#34;) R√©aliser une requete du service :\ncurl $IP:$PORT L\u0026rsquo;exemple de ConfigMap pr√©sent√© pr√©c√©demment contenait une cha√Æne de connexion √† une base de donn√©es (\u0026ldquo;user=MyUserName;password=*\u0026rdquo;). Les donn√©es sensibles comme les mots de passe peuvent √™tre plac√©es dans un autre r√©cipient appel√© Secret.\nCr√©er des secrets kubectl create secret generic mysecret --from-literal=user=\u0026#39;MyUserName\u0026#39; --from-literal=password=\u0026#39;mypassword\u0026#39; kubectl get secrets NAME TYPE DATA AGE\rbuilder-dockercfg-96ml5 kubernetes.io/dockercfg 1 3d6h\rbuilder-token-h5g82 kubernetes.io/service-account-token 4 3d6h\rbuilder-token-vqjqz kubernetes.io/service-account-token 4 3d6h\rdefault-dockercfg-bsnjr kubernetes.io/dockercfg 1 3d6h\rdefault-token-bl77s kubernetes.io/service-account-token 4 3d6h\rdefault-token-vlzsl kubernetes.io/service-account-token 4 3d6h\rdeployer-dockercfg-k6npn kubernetes.io/dockercfg 1 3d6h\rdeployer-token-4hb78 kubernetes.io/service-account-token 4 3d6h\rdeployer-token-vvh6r kubernetes.io/service-account-token 4 3d6h\rmysecret Opaque 2 5s L\u0026rsquo;utilisateur et le mot de passe ne sont pas imm√©diatement visibles :\nName: mysecret\rNamespace: myspace\rLabels: \u0026lt;none\u0026gt;\rAnnotations: \u0026lt;none\u0026gt;\rType: Opaque\rData\r====\rpassword: 10 bytes\ruser: 10 bytes apiVersion: v1\rdata:\rpassword: bXlwYXNzd29yZA==\ruser: TXlVc2VyTmFtZQ==\rkind: Secret\rmetadata:\rcreationTimestamp: \u0026#34;2020-03-31T20:19:26Z\u0026#34;\rname: mysecret\rnamespace: myspace\rresourceVersion: \u0026#34;4944690\u0026#34;\rselfLink: /api/v1/namespaces/myspace/secrets/mysecret\ruid: e8c5f12e-bd71-4d6b-8d8c-7af9ed6439f8\rtype: Opaque Vous pouvez voir les secrets en courant :\necho \u0026#39;bXlwYXNzd29yZA==\u0026#39; | base64 --decode mypassword echo \u0026#39;TXlVc2VyTmFtZQ==\u0026#39; | base64 --decode MyUserName Ou les obtenir en utilisant kubectl :\nkubectl get secret mysecret -o jsonpath=\u0026#39;{.data.password}\u0026#39; | base64 --decode Les secrets sont fournis au Pod via des montages de volumes :\nvolumeMounts:\r- name: mysecretvolume\rmountPath: /mystuff/mysecretvolume Nouveau d√©ploiement avec le volume secret :\nvim apps/kubefiles/myboot-deployment-configuration-secret.yml apiVersion: apps/v1\rkind: Deployment\rmetadata:\rlabels:\rapp: myboot\rname: myboot\rspec:\rreplicas: 1\rselector:\rmatchLabels:\rapp: myboot\rtemplate:\rmetadata:\rlabels:\rapp: myboot\rspec:\rcontainers:\r- name: myboot\rimage: quay.io/rhdevelopers/myboot:v1\rports:\r- containerPort: 8080\rvolumeMounts:\r- name: mysecretvolume #\u0026lt;.\u0026gt;\rmountPath: /mystuff/secretstuff\rreadOnly: true\rresources:\rrequests:\rmemory: \u0026#34;300Mi\u0026#34;\rcpu: \u0026#34;250m\u0026#34; # 1/4 core\rlimits:\rmemory: \u0026#34;400Mi\u0026#34;\rcpu: \u0026#34;1000m\u0026#34; # 1 core\rvolumes:\r- name: mysecretvolume #\u0026lt;.\u0026gt;\rsecret:\rsecretName: mysecret kubectl replace -f apps/kubefiles/myboot-deployment-configuration-secret.yml Exec dans le Pod nouvellement cr√©√© :\nPODNAME=$(kubectl get pod -l app=myboot -o name)\rkubectl exec $PODNAME -- cat /mystuff/secretstuff/password R√©sultat\nmypassword Vous pourriez fournir l\u0026rsquo;emplacement de /mystuff/mysecretvolume au pod via une variable d\u0026rsquo;environnement afin que l\u0026rsquo;application sache o√π chercher.\nSupprimer vos ressources\nkubectl delete deployment myboot\rkubectl delete service myboot "},{"uri":"https://maxime-cls.github.io/kubernetes-tutorial/kubernetes/%C3%A9l%C3%A9mentaire/mise-a-jour/","title":"Mise √† jour permanentes","tags":[],"description":"","content":"Pr√©requis Minikube Install Driver none kubectl Install Stern Docs Release jq Install 3 terminal SSH Assurez-vous que vous √™tes dans le bon espace de noms :\nkubectl config set-context --current --namespace=myspace D√©ployez l\u0026rsquo;application Spring Boot si n√©cessaire :\nkubectl apply -f apps/kubefiles/myboot-deployment-resources-limits.yml\rkubectl apply -f apps/kubefiles/myboot-service.yml Terminal 1 : regardez les Pods.\nwatch kubectl get pods Terminal 2: curl loop the service.\nIP=$(minikube ip -p devnation)\rPORT=$(kubectl get service/myboot -o jsonpath=\u0026#34;{.spec.ports[*].nodePort}\u0026#34;) R√©aliser une requete sur le service :\ncurl $IP:$PORT Et lancez le script de la boucle :\nwhile true\rdo curl $IP:$PORT\rsleep .3\rdone Terminal 3 : Ex√©cuter des commandes.\nD√©crire le d√©ploiement :\nkubectl describe deployment myboot .\r.\r.\rReplicas: 1 desired | 1 updated | 1 total | 1 available | 0 unavailable\rStrategyType: RollingUpdate\rMinReadySeconds: 0\rRollingUpdateStrategy: 25% max unavailable, 25% max surge\r.\r.\r. Les options StrategyType comprennent RollingUpdate et Recreate :\nModifier les repliquas :\nkubectl edit deployment myboot Recherchez les \u0026ldquo;r√©plicas\u0026rdquo; :\nspec:\rprogressDeadlineSeconds: 600\rreplicas: 1\rrevisionHistoryLimit: 10\rselector:\rmatchLabels:\rapp: myboot Et mettez √† jour √† \u0026ldquo;2\u0026rdquo; :\nspec:\rprogressDeadlineSeconds: 600\rreplicas: 2\rrevisionHistoryLimit: 10\rselector:\rmatchLabels:\rapp: myboot Enregistrez et un nouveau pod prendra vie :\nkubectl get pods NAME READY STATUS RESTARTS AGE\rmyboot-d78fb6d58-2fqml 1/1 Running 0 25s\rmyboot-d78fb6d58-ljkjp 1/1 Running 0 3m Modifiez l\u0026rsquo;image associ√©e au d√©ploiement :\nkubectl edit deployment myboot Trouvez l\u0026rsquo;attribut de l\u0026rsquo;image :\nspec:\rcontainers:\r- image: quay.io/rhdevelopers/myboot:v1\rimagePullPolicy: IfNotPresent\rname: myboot et changez l\u0026rsquo;image myboot:v2 :\nspec:\rcontainers:\r- image: quay.io/rhdevelopers/myboot:v2\rimagePullPolicy: IfNotPresent\rname: myboot kubectl get pods NAME READY STATUS RESTARTS AGE\rmyboot-7fbc4b97df-4ntmk 1/1 Running 0 9s\rmyboot-7fbc4b97df-qtkzj 0/1 ContainerCreating 0 0s\rmyboot-d78fb6d58-2fqml 1/1 Running 0 3m29s\rmyboot-d78fb6d58-ljkjp 1/1 Terminating 0 8m Et la sortie du terminal 2 :\nAloha from Spring Boot! 211 on myboot-d78fb6d58-2fqml\rAloha from Spring Boot! 212 on myboot-d78fb6d58-2fqml\rBonjour from Spring Boot! 0 on myboot-7fbc4b97df-4ntmk\rBonjour from Spring Boot! 1 on myboot-7fbc4b97df-4ntmk V√©rifiez l\u0026rsquo;√©tat du d√©ploiement :\nkubectl rollout status deployment myboot deployment \u0026#34;myboot\u0026#34; successfully rolled out Remarquez qu\u0026rsquo;il y a un nouveau RS :\nkubectl get rs NAME DESIRED CURRENT READY AGE\rmyboot-7fbc4b97df 2 2 2 116s\rmyboot-d78fb6d58 0 0 0 10m D√©crire le d√©ploiement :\nkubectl describe deployment myboot Et consultez la section \u0026ldquo;√âv√©nements\u0026rdquo; :\n...\rEvents:\rType Reason Age From Message\r---- ------ ---- ---- -------\rNormal ScalingReplicaSet 16m deployment-controller Scaled up replica set myboot-d78fb6d58 to 1\rNormal ScalingReplicaSet 6m15s deployment-controller Scaled up replica set myboot-d78fb6d58 to 2\rNormal ScalingReplicaSet 2m55s deployment-controller Scaled up replica set myboot-7fbc4b97df to 1\rNormal ScalingReplicaSet 2m46s deployment-controller Scaled down replica set myboot-d78fb6d58 to 1\rNormal ScalingReplicaSet 2m46s deployment-controller Scaled up replica set myboot-7fbc4b97df to 2\rNormal ScalingReplicaSet 2m37s deployment-controller Scaled down replica set myboot-d78fb6d58 to 0 Retour √† la version 1 :\nkubectl set image deployment myboot myboot=quay.io/rhdevelopers/myboot:v1 "},{"uri":"https://maxime-cls.github.io/kubernetes-tutorial/kubernetes/intermediare/operator/","title":"Operator","tags":[],"description":"","content":"Pr√©requis Minikube Install Driver none kubectl Install Stern Docs Release jq Install 3 terminal SSH Les ressources personnalis√©es √©tendent l\u0026rsquo;API\nLes contr√¥leurs personnalis√©s fournissent la fonctionnalit√© - qui maintient continuellement l\u0026rsquo;√©tat souhait√© - pour surveiller son √©tat et rapprocher la ressource de la configuration.\nDocs Custom Resources\nDocs Custom Resource Definition\nD√©finitions de ressources personnalis√©es (CRD) dans la version 1.7\nCRDs kubectl get crds --all-namespaces\rkubectl api-resources Exemple CRD\napiVersion: apiextensions.k8s.io/v1beta1\rkind: CustomResourceDefinition\rmetadata:\rname: pizzas.mykubernetes.acme.org\rlabels:\rapp: pizzamaker\rmylabel: stuff\rspec:\rgroup: mykubernetes.acme.org\rscope: Namespaced\rversion: v1beta2\rnames:\rkind: Pizza\rlistKind: PizzaList\rplural: pizzas\rsingular: pizza\rshortNames:\r- pz Ajoutez des Pizzas\nmkdir -p apps/pizzas/\rvim pizza-crd.yaml pizza-crd.yaml\napiVersion: apiextensions.k8s.io/v1\rkind: CustomResourceDefinition\rmetadata:\rname: pizzas.mykubernetes.acme.org\rlabels:\rapp: pizzamaker\rmylabel: stuff\rspec:\rgroup: mykubernetes.acme.org\rscope: Namespaced\rversions:\r- name: v1\rserved: true\rstorage: true\rschema:\ropenAPIV3Schema:\rdescription: \u0026#34;A custom resource for making yummy pizzas\u0026#34; #\u0026lt;.\u0026gt;\rtype: object\rproperties:\rspec:\rtype: object\rdescription: \u0026#34;Information about our pizza\u0026#34;\rproperties:\rtoppings: #\u0026lt;.\u0026gt;\rtype: array\ritems:\rtype: string\rdescription: \u0026#34;List of toppings for our pizza\u0026#34;\rsauce: #\u0026lt;.\u0026gt;\rtype: string\rdescription: \u0026#34;The name of the sauce to use on our pizza\u0026#34;\rnames:\rkind: Pizza #\u0026lt;.\u0026gt;\rlistKind: PizzaList\rplural: pizzas\rsingular: pizza\rshortNames:\r- pz kubectl create namespace pizzahat\rkubectl config set-context --current --namespace=pizzahat\rkubectl apply -f apps/pizzas/pizza-crd.yaml Fait maintenant partie de l\u0026rsquo;API\nkubectl get crds | grep pizza R√©sultat\nNAME CREATED AT\rpizzas.mykubernetes.acme.org 2022-01-23T16:26:11Z kubectl api-resources | grep pizzas R√©sultat\npizzas pz mykubernetes.acme.org true Pizza D√©ploiement de l\u0026rsquo;op√©rateur\nvim apps/pizzas/pizza-deployment.yaml pizza-deployment.yaml\napiVersion: rbac.authorization.k8s.io/v1\rkind: ClusterRole\rmetadata:\rname: quarkus-operator-example\rrules:\r- apiGroups:\r- \u0026#39;\u0026#39;\rresources:\r- pods\rverbs:\r- get\r- list\r- watch\r- create\r- update\r- delete\r- patch\r- apiGroups:\r- apiextensions.k8s.io\rresources:\r- customresourcedefinitions\rverbs:\r- list\r- apiGroups:\r- mykubernetes.acme.org\rresources:\r- pizzas\rverbs:\r- list\r- watch\r---\rapiVersion: v1\rkind: ServiceAccount\rmetadata:\rname: quarkus-operator-example\r---\rapiVersion: rbac.authorization.k8s.io/v1\rkind: ClusterRoleBinding\rmetadata:\rname: quarkus-operator-example\rsubjects:\r- kind: ServiceAccount\rname: quarkus-operator-example\rnamespace: pizzahat\rroleRef:\rkind: ClusterRole\rname: quarkus-operator-example\rapiGroup: rbac.authorization.k8s.io\r---\rapiVersion: apps/v1\rkind: Deployment\rmetadata:\rname: quarkus-operator-example\rspec:\rselector:\rmatchLabels:\rapp: quarkus-operator-example\rreplicas: 1\rtemplate:\rmetadata:\rlabels:\rapp: quarkus-operator-example\rspec:\rserviceAccountName: quarkus-operator-example\rcontainers:\r- image: quay.io/rhdevelopers/pizza-operator:1.0.1\rname: quarkus-operator-example\rimagePullPolicy: IfNotPresent kubectl apply -f apps/pizzas/pizza-deployment.yaml\rkubectl get pods NAME READY STATUS RESTARTS AGE\rquarkus-operator-example-5f5bf777bc-glfg9 1/1 Running 0 58s Faire des pizzas\nvim apps/pizzas/cheese-pizza.yaml cheese-pizza.yaml\napiVersion: mykubernetes.acme.org/v1\rkind: Pizza\rmetadata:\rname: cheesep\rspec:\rtoppings:\r- mozzarella\rsauce: regular kubectl apply -f apps/pizzas/cheese-pizza.yaml\rkubectl get pizzas NAME AGE\rcheesep 4s kubectl describe pizza cheesep Name: cheesep\rNamespace: pizzahat\rLabels: \u0026lt;none\u0026gt;\rAnnotations: kubectl.kubernetes.io/last-applied-configuration:\r{\u0026#34;apiVersion\u0026#34;:\u0026#34;mykubernetes.acme.org/v1beta2\u0026#34;,\u0026#34;kind\u0026#34;:\u0026#34;Pizza\u0026#34;,\u0026#34;metadata\u0026#34;:{\u0026#34;annotations\u0026#34;:{},\u0026#34;name\u0026#34;:\u0026#34;cheesep\u0026#34;,\u0026#34;namespace\u0026#34;:\u0026#34;pizzahat\u0026#34;},\u0026#34;spec\u0026#34;:...\rAPI Version: mykubernetes.acme.org/v1beta2\rKind: Pizza\r... kubectl get pods NAME READY STATUS RESTARTS AGE\rcheesep-pod 0/1 Completed 0 3s\rquarkus-operator-example-5f5bf777bc-glfg9 1/1 Running 0 44m Et v√©rifiez les logs du Pod de fromage :\nkubectl logs cheesep-pod __ ____ __ _____ ___ __ ____ ______\r--/ __ \\/ / / / _ | / _ \\/ //_/ / / / __/\r-/ /_/ / /_/ / __ |/ , _/ ,\u0026lt; / /_/ /\\ \\\r--\\___\\_\\____/_/ |_/_/|_/_/|_|\\____/___/\r2022-07-23 09:03:11,537 INFO [io.quarkus] (main) pizza-maker 1.0-SNAPSHOT (powered by Quarkus 1.4.0.CR1) started in 0.006s.\r2022-07-23 09:03:11,537 INFO [io.quarkus] (main) Profile prod activated.\r2022-07-23 09:03:11,537 INFO [io.quarkus] (main) Installed features: [cdi]\rDoing The Base\rAdding Sauce regular\rAdding Toppings [mozzarella]\rBaking\rBaked\rReady For Delivery\r2022-01-23 09:03:12,038 INFO [io.quarkus] (main) pizza-maker stopped in 0.000s Faire plus de pizzas\nvim apps/pizzas/meat-lovers.yaml meat-lovers.yaml\napiVersion: mykubernetes.acme.org/v1\rkind: Pizza\rmetadata:\rname: meatsp\rspec:\rtoppings:\r- mozzarella\r- pepperoni\r- sausage\r- bacon\rsauce: extra vim apps/pizzas/veggie-lovers.yaml apiVersion: mykubernetes.acme.org/v1\rkind: Pizza\rmetadata:\rname: veggiep\rspec:\rtoppings:\r- mozzarella\r- black olives\rsauce: extra kubectl apply -f apps/pizzas/meat-lovers.yaml\rkubectl apply -f apps/pizzas/veggie-lovers.yaml\rkubectl get pizzas --all-namespaces Manger toutes les pizzas\nkubectl delete pizzas --all Supprimer les ressources\nkubectl delete all --all Cr√©er un peu de Kafka Kafka pour Minikube Cr√©ez un nouvel espace de nom pour cette exp√©rience :\nkubectl create namespace franz\rkubectl config set-context --current --namespace=franz D√©ployer l\u0026rsquo;op√©rateur Kafka :\ncurl -sL https://github.com/operator-framework/operator-lifecycle-manager/releases/download/v0.20.0/install.sh | bash -s v0.20.0 kubectl create -f https://operatorhub.io/install/strimzi-kafka-operator.yaml kubectl get csv Attendez un peu jusqu\u0026rsquo;√† l\u0026rsquo;√©tat succ√®s :\nwatch kubectl get csv NAME DISPLAY VERSION REPLACES PHASE\rstrimzi-cluster-operator.v0.27.1 Strimzi 0.27.1 strimzi-cluster-operator.v0.27.0 Succeeded D√©marrer une veille dans un autre terminal :\nwatch kubectl get pods Ensuite, d√©ployez la ressource en demandant un cluster Kafka :\nvim apps/kubefiles/mykafka.yml mykafka.yml\napiVersion: kafka.strimzi.io/v1beta2\rkind: Kafka\rmetadata:\rname: my-cluster\rspec:\rkafka:\rversion: 3.0.0\rreplicas: 3\rlisteners:\r- name: plain\rport: 9092\rtype: internal\rtls: false\r- name: tls\rport: 9093\rtype: internal\rtls: true\rconfig:\roffsets.topic.replication.factor: 3\rtransaction.state.log.replication.factor: 3\rtransaction.state.log.min.isr: 2\rlog.message.format.version: \u0026#39;3.0\u0026#39;\rinter.broker.protocol.version: \u0026#39;3.0\u0026#39;\rstorage:\rtype: ephemeral\rzookeeper:\rreplicas: 3\rstorage:\rtype: ephemeral\rentityOperator:\rtopicOperator: {}\ruserOperator: {} kubectl apply -f apps/kubefiles/mykafka.yml R√©sultat :\nNAME READY STATUS RESTARTS AGE\rmy-cluster-entity-operator-66676cb9fb-fzckz 2/2 Running 0 29s\rmy-cluster-kafka-0 2/2 Running 0 60s\rmy-cluster-kafka-1 2/2 Running 0 60s\rmy-cluster-kafka-2 2/2 Running 0 60s\rmy-cluster-zookeeper-0 2/2 Running 0 92s\rmy-cluster-zookeeper-1 2/2 Running 0 92s\rmy-cluster-zookeeper-2 2/2 Running 0 92s kubectl get kafkas NAME DESIRED KAFKA REPLICAS DESIRED ZK REPLICAS READY WARNINGS\rmy-cluster 3 3 True True Supprimer les ressources\nkubectl delete namespace pizzahat\rkubectl delete -f apps/pizzas/pizza-crd.yaml\rkubectl delete kafka my-cluster\rkubectl delete namespace franz "},{"uri":"https://maxime-cls.github.io/kubernetes-tutorial/kubernetes/d%C3%A9butant/pod-replica-deployment/","title":"Pod, Replicaset, Deployment","tags":[],"description":"","content":"Pr√©requis Minikube Install Driver none kubectl Install Stern Docs Release jq Install 3 terminal SSH Commencez par cr√©er un espace de noms dans lequel vous pourrez travailler :\nkubectl create namespace myspace\rkubectl config set-context --current --namespace=myspace Pod Cr√©er un naked pod :\ncat \u0026lt;\u0026lt;EOF | kubectl apply -f -\rapiVersion: v1\rkind: Pod\rmetadata:\rname: quarkus-demo\rspec:\rcontainers:\r- name: quarkus-demo\rimage: quay.io/rhdevelopers/quarkus-demo:v1\rEOF Observez le cycle de vie du pod :\nterminal 2 :\nwatch kubectl get pods NAME READY STATUS RESTARTS AGE\rquarkus-demo 0/1 ContainerCreating 0 10s De la cr√©ation de conteneurs √† l\u0026rsquo;ex√©cution avec Ready 1/1 :\nNAME READY STATUS RESTARTS AGE\rquarkus-demo 1/1 Running 0 18s V√©rifiez la demande dans le Pod :\nkubectl exec -it quarkus-demo /bin/sh Ex√©cutez la commande suivante. Notez que, comme vous √™tes dans l\u0026rsquo;instance du conteneur, le nom d\u0026rsquo;h√¥te est localhost.\ncurl localhost:8080 Supersonic Subatomic Java with Quarkus quarkus-demo:1\rexit Supprimons le Pod pr√©c√©dent :\nkubectl delete pod quarkus-demo terminal 2\nwatch kubectl get pods NAME READY STATUS RESTARTS AGE\rquarkus-demo 0/1 Terminating 0 9m35s\rNo resources found in myspace namespace. Le pod Naked dispara√Æt √† jamais.\nUn pod naked est un pod nue et il ne sera pas replanifier en cas d\u0026rsquo;erreur sur le pod ou de suppression.\nReplicaset Cr√©er un replicaset :\ncat \u0026lt;\u0026lt;EOF | kubectl apply -f -\rapiVersion: apps/v1\rkind: ReplicaSet\rmetadata:\rname: rs-quarkus-demo\rspec:\rreplicas: 3\rselector:\rmatchLabels:\rapp: quarkus-demo\rtemplate:\rmetadata:\rlabels:\rapp: quarkus-demo\renv: dev\rspec:\rcontainers:\r- name: quarkus-demo\rimage: quay.io/rhdevelopers/quarkus-demo:v1\rEOF Obtenez les pods avec des √©tiquettes :\nterminal 2\nwatch kubectl get pods --show-labels NAME READY STATUS RESTARTS AGE LABELS\rrs-quarkus-demo-jd6jk 1/1 Running 0 58s app=quarkus-demo,env=dev\rrs-quarkus-demo-mlnng 1/1 Running 0 58s app=quarkus-demo,env=dev\rrs-quarkus-demo-t26gt 1/1 Running 0 58s app=quarkus-demo,env=dev Afficher les replicaset cr√©√© :\nkubectl get rs NAME DESIRED CURRENT READY AGE\rrs-quarkus-demo 3 3 3 79s D√©crire le replicaset\nkubectl describe rs rs-quarkus-demo Les pods sont la \u0026ldquo;propri√©t√©\u0026rdquo; du ReplicaSet :\nkubectl get pod rs-quarkus-demo-mlnng -o json | jq \u0026#34;.metadata.ownerReferences[]\u0026#34; {\r\u0026#34;apiVersion\u0026#34;: \u0026#34;apps/v1\u0026#34;,\r\u0026#34;blockOwnerDeletion\u0026#34;: true,\r\u0026#34;controller\u0026#34;: true,\r\u0026#34;kind\u0026#34;: \u0026#34;ReplicaSet\u0026#34;,\r\u0026#34;name\u0026#34;: \u0026#34;rs-quarkus-demo\u0026#34;,\r\u0026#34;uid\u0026#34;: \u0026#34;1ed3bb94-dfa5-40ef-8f32-fbc9cf265324\u0026#34;\r} Supprimez maintenant un pod, tout en regardant les pods :\nkubectl delete pod rs-quarkus-demo-mlnng Et une nouvelle pod va na√Ætre pour le remplacer :\nNAME READY STATUS RESTARTS AGE LABELS\rrs-quarkus-demo-2txwk 0/1 ContainerCreating 0 2s app=quarkus-demo,env=dev\rrs-quarkus-demo-jd6jk 1/1 Running 0 109s app=quarkus-demo,env=dev\rrs-quarkus-demo-t26gt 1/1 Running 0 109s app=quarkus-demo,env=dev Supprimez le ReplicaSet pour supprimer tous les pods associ√©s :\nkubectl delete rs rs-quarkus-demo Deploiement Cr√©er un d√©ploiement de 3 replicaset d\u0026rsquo;un m√™me conteneur.\ncat \u0026lt;\u0026lt;EOF | kubectl apply -f -\rapiVersion: apps/v1\rkind: Deployment\rmetadata:\rname: quarkus-demo-deployment\rspec:\rreplicas: 3\rselector:\rmatchLabels:\rapp: quarkus-demo\rtemplate:\rmetadata:\rlabels:\rapp: quarkus-demo\renv: dev\rspec:\rcontainers:\r- name: quarkus-demo\rimage: quay.io/rhdevelopers/quarkus-demo:v1\rimagePullPolicy: Always\rports:\r- containerPort: 8080\rEOF kubectl get pods --show-labels NAME READY STATUS RESTARTS AGE LABELS\rquarkus-demo-deployment-5979886fb7-c888m 1/1 Running 0 17s app=quarkus-demo,env=dev,pod-template-hash=5979886fb7\rquarkus-demo-deployment-5979886fb7-gdtnz 1/1 Running 0 17s app=quarkus-demo,env=dev,pod-template-hash=5979886fb7\rquarkus-demo-deployment-5979886fb7-grf59 1/1 Running 0 17s app=quarkus-demo,env=dev,pod-template-hash=5979886f Executer une commande shell dans le pods :\nkubectl exec -it quarkus-demo-deployment-5979886fb7-c888m -- curl localhost:8080 Supersonic Subatomic Java with Quarkus quarkus-demo-deployment-5979886fb7-c888m:1 A vous de jouez ! Cr√©er un pod avec des Resource Requests et Limits\nCr√©er un namespace de noms limit.\nDans ce Namespace, cr√©ez un Pod nomm√© resource-checker de l\u0026rsquo;image httpd:alpine.\nLe conteneur doit √™tre nomm√© my-container.\nIl doit demander 30m de CPU et √™tre limit√© √† 300m de CPU.\nIl doit demander 30Mi de m√©moire et √™tre limit√© √† 30Mi de m√©moire.\n"},{"uri":"https://maxime-cls.github.io/kubernetes-tutorial/kubernetes/d%C3%A9butant/","title":"D√©butant","tags":[],"description":"","content":""},{"uri":"https://maxime-cls.github.io/kubernetes-tutorial/kubernetes/%C3%A9l%C3%A9mentaire/liveness-readiness/","title":"Liveness &amp; Readiness","tags":[],"description":"","content":"Pr√©requis Minikube Install Driver none kubectl Install Stern Docs Release jq Install 3 terminal SSH Assurez-vous que vous √™tes dans le bon espace de noms :\nkubectl config set-context --current --namespace=myspace Assurez-vous que rien d\u0026rsquo;autre n\u0026rsquo;est d√©ploy√© :\nkubectl get all No resources found in myspace namespace. D√©ployez une application avec le jeu de sondes Live and Ready :\ncat \u0026lt;\u0026lt;EOF | kubectl apply -f -\rapiVersion: apps/v1\rkind: Deployment\rmetadata:\rname: myboot\rspec:\rreplicas: 3\rselector:\rmatchLabels:\rapp: myboot\rtemplate:\rmetadata:\rlabels:\rapp: myboot\renv: dev\rspec:\rcontainers:\r- name: myboot\rimage: quay.io/rhdevelopers/myboot:v1\rimagePullPolicy: Always\rports:\r- containerPort: 8080\rresources:\rrequests:\rmemory: \u0026#34;300Mi\u0026#34;\rcpu: \u0026#34;250m\u0026#34; # 1/4 core\rlimits:\rmemory: \u0026#34;400Mi\u0026#34;\rcpu: \u0026#34;1000m\u0026#34; # 1 core\rlivenessProbe:\rhttpGet:\rport: 8080\rpath: /\rinitialDelaySeconds: 10\rperiodSeconds: 5\rtimeoutSeconds: 2\rreadinessProbe:\rhttpGet:\rpath: /health\rport: 8080\rinitialDelaySeconds: 10\rperiodSeconds: 3\rEOF D√©crivez le d√©ploiement :\nkubectl describe deployment myboot ...\rImage: quay.io/rhdevelopers/myboot:v1\rPort: 8080/TCP\rHost Port: 0/TCP\rLimits:\rcpu: 1\rmemory: 400Mi\rRequests:\rcpu: 250m\rmemory: 300Mi\rLiveness: http-get http://:8080/ delay=10s timeout=2s period=5s #success=1 #failure=3\rReadiness: http-get http://:8080/health delay=10s timeout=1s period=3s #success=1 #failure=3\r... D√©ployer un service :\nkubectl apply -f apps/kubefiles/myboot-service.yml Cr√©er les variables IP et PORT\nIP=$(minikube ip)\rPORT=$(kubectl get service/myboot -o jsonpath=\u0026#34;{.spec.ports[*].nodePort}\u0026#34;) R√©aliser une requete sur le service :\ncurl $IP:$PORT Et lancez le script de la boucle :\nwhile true\rdo curl $IP:$PORT\rsleep .3\rdone Changez l\u0026rsquo;image :\nkubectl set image deployment/myboot myboot=quay.io/rhdevelopers/myboot:v2 Et remarquez la mise √† jour sans erreur :\nAloha from Spring Boot! 131 on myboot-845968c6ff-k4rvb\rAloha from Spring Boot! 134 on myboot-845968c6ff-9wvt9\rAloha from Spring Boot! 122 on myboot-845968c6ff-9824z\rBonjour from Spring Boot! 0 on myboot-8449d5468d-m88z4\rBonjour from Spring Boot! 1 on myboot-8449d5468d-m88z4\rAloha from Spring Boot! 135 on myboot-845968c6ff-9wvt9\rAloha from Spring Boot! 133 on myboot-845968c6ff-k4rvb\rAloha from Spring Boot! 137 on myboot-845968c6ff-9wvt9\rBonjour from Spring Boot! 3 on myboot-8449d5468d-m88z4 Regardez les points d\u0026rsquo;extr√©mit√© pour voir quels pods font partie du service :\nkubectl get endpoints myboot -o json | jq \u0026#39;.subsets[].addresses[].ip\u0026#39; Ce sont les IP des Pods qui ont pass√© leur test de pr√©paration :\n\u0026#34;10.129.2.40\u0026#34;\r\u0026#34;10.130.2.37\u0026#34;\r\u0026#34;10.130.2.38\u0026#34; Readiness Probe Exec en un seul Pod et changer son indicateur de disponibilit√© :\nkubectl exec -it myboot-845968c6ff-k5lcb /bin/bash curl localhost:8080/misbehave\rexit V√©rifiez que le pod n\u0026rsquo;est plus pr√™t :\nNAME READY STATUS RESTARTS AGE\rmyboot-845968c6ff-9wshg 1/1 Running 0 11m\rmyboot-845968c6ff-k5lcb 0/1 Running 0 12m\rmyboot-845968c6ff-zsgx2 1/1 Running 0 11m Maintenant, v√©rifiez les points de terminaison :\nkubectl get endpoints myboot -o json | jq \u0026#39;.subsets[].addresses[].ip\u0026#39; Et ce pod est maintenant absent de l\u0026rsquo;√©quilibreur de charge du service :\n\u0026#34;10.130.2.37\u0026#34;\r\u0026#34;10.130.2.38\u0026#34; Ce qui est aussi une √©vidence dans la boucle de la boucle :\nAloha from Spring Boot! 845 on myboot-845968c6ff-9wshg\rAloha from Spring Boot! 604 on myboot-845968c6ff-zsgx2\rAloha from Spring Boot! 846 on myboot-845968c6ff-9wshg Liveness Probe kubectl set image deployment/myboot myboot=quay.io/rhdevelopers/myboot:v3 Laissez le d√©ploiement se terminer sur les 3 r√©pliques :\nwatch kubectl get pods\rNAME READY STATUS RESTARTS AGE\rmyboot-56659c9d69-6sglj 1/1 Running 0 2m2s\rmyboot-56659c9d69-mdllq 1/1 Running 0 97s\rmyboot-56659c9d69-zjt6q 1/1 Running 0 72s Et comme on le voit dans la boucle de curl/poller :\nJambo from Spring Boot! 40 on myboot-56659c9d69-mdllq\rJambo from Spring Boot! 26 on myboot-56659c9d69-zjt6q\rJambo from Spring Boot! 71 on myboot-56659c9d69-6sglj Modifiez le d√©ploiement pour qu\u0026rsquo;il pointe vers l\u0026rsquo;URL /alive :\nkubectl edit deployment myboot Et changez la sonde de Liveness probe :\n...\rspec:\rcontainers:\r- image: quay.io/rhdevelopers/myboot:v3\rimagePullPolicy: Always\rlivenessProbe:\rfailureThreshold: 3\rhttpGet:\rpath: /alive\rport: 8080\rscheme: HTTP\rinitialDelaySeconds: 10\rperiodSeconds: 5\rsuccessThreshold: 1\rtimeoutSeconds: 2\rname: myboot\r... Sauvegardez et fermez l\u0026rsquo;√©diteur, ce qui permet √† cette modification d\u0026rsquo;√™tre appliqu√©e.\nwatch kubectl get pods NAME READY STATUS RESTARTS AGE\rmyboot-558b4f8678-nw762 1/1 Running 0 59s\rmyboot-558b4f8678-qbrgc 1/1 Running 0 81s\rmyboot-558b4f8678-z7f9n 1/1 Running 0 36s Maintenant, choisissez un pod, ex√©cutez-la et tirez dessus :\nkubectl exec -it myboot-558b4f8678-qbrgc /bin/bash curl localhost:8080/shot Et vous verrez qu\u0026rsquo;il sera red√©marr√© :\nNAME READY STATUS RESTARTS AGE\rmyboot-558b4f8678-nw762 1/1 Running 0 4m7s\rmyboot-558b4f8678-qbrgc 1/1 Running 1 4m29s\rmyboot-558b4f8678-z7f9n 1/1 Running 0 3m44s De plus, votre ex√©cution sera termin√©e :\nkubectl exec -it myboot-558b4f8678-qbrgc /bin/bash curl localhost:8080/shot I have been shot in the head1000610000@myboot-558b4f8678-qbrgc:/app$ command terminated with exit code 137 Et vos utilisateurs finaux ne verront pas d\u0026rsquo;erreurs :\nJambo from Spring Boot! 174 on myboot-558b4f8678-z7f9n\rJambo from Spring Boot! 11 on myboot-558b4f8678-qbrgc\rJambo from Spring Boot! 12 on myboot-558b4f8678-qbrgc\rJambo from Spring Boot! 206 on myboot-558b4f8678-nw762\rJambo from Spring Boot! 207 on myboot-558b4f8678-nw762\rJambo from Spring Boot! 175 on myboot-558b4f8678-z7f9n\rJambo from Spring Boot! 176 on myboot-558b4f8678-z7f9n Supprimer les ressources\nkubectl delete deployment myboot\rkubectl delete service myboot Startup Probe Certaines applications n√©cessitent un temps de d√©marrage suppl√©mentaire lors de leur premi√®re initialisation.\nIl peut s\u0026rsquo;av√©rer difficile d\u0026rsquo;int√©grer ce sc√©nario dans les sondes de disponibilit√©/pr√©paration car vous devez les configurer pour qu\u0026rsquo;elles aient un comportement normal afin de d√©tecter les anomalies pendant le temps d\u0026rsquo;ex√©cution et, en outre, pour couvrir le long temps de d√©marrage.\nLes sondes de d√©marrage r√©solvent ce probl√®me, car une fois que la sonde de d√©marrage a r√©ussi, le reste des sondes prend le relais.\ncat \u0026lt;\u0026lt;EOF | kubectl apply -f -\rapiVersion: apps/v1\rkind: Deployment\rmetadata:\rname: myboot\rspec:\rreplicas: 1\rselector:\rmatchLabels:\rapp: myboot\rtemplate:\rmetadata:\rlabels:\rapp: myboot\renv: dev\rspec:\rcontainers:\r- name: myboot\rimage: quay.io/rhdevelopers/myboot:zoombie\rimagePullPolicy: Always\rports:\r- containerPort: 8080\rresources:\rrequests:\rmemory: \u0026#34;300Mi\u0026#34;\rcpu: \u0026#34;250m\u0026#34; # 1/4 core\rlimits:\rmemory: \u0026#34;400Mi\u0026#34;\rcpu: \u0026#34;1000m\u0026#34; # 1 core\rlivenessProbe:\rhttpGet:\rport: 8080\rpath: /\rinitialDelaySeconds: 10\rperiodSeconds: 5\rtimeoutSeconds: 2\rreadinessProbe:\rhttpGet:\rpath: /health\rport: 8080\rinitialDelaySeconds: 10\rperiodSeconds: 3\rstartupProbe:\rhttpGet:\rpath: /alive\rport: 8080\rfailureThreshold: 12\rperiodSeconds: 5\rEOF La sonde de d√©marrage attend une minute (5 * 12) pour d√©marrer l\u0026rsquo;application.\nL\u0026rsquo;application actuelle renvoie une erreur 503 dans le endpoint /alive, elle ne r√©ussira donc jamais √† d√©marrer et la restartPolicy est appliqu√©e.\nwatch kubectl get pods NAME READY STATUS RESTARTS AGE\rmyboot-579cc5cc47-2bk5p 0/1 Running 0 67s Attendez 60 secondes jusqu\u0026rsquo;√† ce que vous voyiez que le pod est red√©marr√©.\nEt vous verrez qu\u0026rsquo;il a red√©marr√© :\nNAME READY STATUS RESTARTS AGE\rmyboot-579cc5cc47-2bk5p 0/1 Running 1 3m7s Pour que le pod r√©ussisse, ex√©cutez-la et faites-la rena√Ætre :\nkubectl exec -it myboot-579cc5cc47-2bk5p /bin/bash curl localhost:8080/reborn Et enfin, c\u0026rsquo;est parti :\nNAME READY STATUS RESTARTS AGE\rmyboot-579cc5cc47-2bk5p 1/1 Running 1 3m41s D√©crire le pod pour obtenir les statistiques des sondes :\nkubectl describe pod myboot-579cc5cc47-2bk5p Limits:\rcpu: 1\rmemory: 400Mi\rRequests:\rcpu: 250m\rmemory: 300Mi\rLiveness: http-get http://:8080/ delay=10s timeout=2s period=5s #success=1 #failure=3\rReadiness: http-get http://:8080/health delay=10s timeout=1s period=3s #success=1 #failure=3\rStartup: http-get http://:8080/alive delay=0s timeout=1s period=5s #success=1 #failure=12\rEnvironment: \u0026lt;none\u0026gt;\rMounts: Supprimer les ressources\nkubectl delete deployment myboot A vous de jouez ! Cr√©er un d√©ploiement avec une ReadinessProbe\nCr√©ez un d√©ploiement nomm√© space-alien-welcome-message-generator d\u0026rsquo;image httpd:alpine avec 1 replica.\nIl devrait avoir un ReadinessProbe qui ex√©cute la commande stat /tmp/ready. Cela signifie qu\u0026rsquo;une fois que le fichier existe, le pod doit √™tre pr√™t.\nLes valeurs initialDelaySeconds et periodSeconds doivent √™tre respectivement de 10 et 5.\nCr√©ez le d√©ploiement et observez que le module n\u0026rsquo;est pas pr√™t.\n"},{"uri":"https://maxime-cls.github.io/kubernetes-tutorial/kubernetes/d%C3%A9butant/services/","title":"Service","tags":[],"description":"","content":"Pr√©requis Minikube Install Driver none kubectl Install Stern Docs Release jq Install 3 terminal SSH Cela fait suite √† la cr√©ation du d√©ploiement dans le chapitre pr√©c√©dent.\nAssurez-vous que vous √™tes dans le bon espace de noms :\nkubectl config set-context --current --namespace=myspace Assurez-vous que vous avez le D√©ploiement :\nkubectl get deployments NAME READY UP-TO-DATE AVAILABLE AGE\rquarkus-demo-deployment 3/3 3 3 8m33s Assurez-vous que vous avez un RS :\nkubectl get rs NAME DESIRED CURRENT READY AGE\rquarkus-demo-deployment-5979886fb7 3 3 3 8m56s Assurez-vous d\u0026rsquo;avoir des Pods :\nkubectl get pods NAME READY STATUS RESTARTS AGE\rquarkus-demo-deployment-5979886fb7-c888m 1/1 Running 0 9m17s\rquarkus-demo-deployment-5979886fb7-gdtnz 1/1 Running 0 9m17s\rquarkus-demo-deployment-5979886fb7-grf59 1/1 Running 0 9m17s Cr√©er un service\ncat \u0026lt;\u0026lt;EOF | kubectl apply -f -\rapiVersion: v1\rkind: Service\rmetadata:\rname: the-service\rspec:\rselector:\rapp: quarkus-demo\rports:\r- protocol: TCP\rport: 80\rtargetPort: 8080\rtype: LoadBalancer\rEOF watch kubectl get services NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE\rmyapp LoadBalancer 172.30.103.41 \u0026lt;pending\u0026gt; 8080:31974/TCP 4s minikube addons enable ingress\rkubectl get pods -n ingress-nginx NAME READY STATUS RESTARTS AGE\ringress-nginx-admission-create-g9g49 0/1 Completed 0 11m\ringress-nginx-admission-patch-rqp78 0/1 Completed 1 11m\ringress-nginx-controller-59b45fb494-26npt 1/1 Running 0 11m minikube tunnel watch kubectl get services NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE\rthe-service LoadBalancer 10.111.248.227 10.111.248.227 80:32591/TCP 52m Cr√©er les variables IP et PORT :\nminikube service the-service --url -n myspace http://172.17.0.15:31637 curl $IP:$PORT Supersonic Subatomic Java with Quarkus quarkus-demo-deployment-5979886fb7-grf59:1 A vous de jouez ! Cr√©er des services pour les d√©ploiements existants\nkind: ConfigMap\rapiVersion: v1\rmetadata:\rname: nginx-conf\rdata:\rnginx.conf: |\ruser nginx;\rworker_processes 3;\rerror_log /var/log/nginx/error.log;\revents {\rworker_connections 10240;\r}\rhttp {\rserver {\rlisten 80;\rserver_name _;\rroot /usr/share/nginx/html;\rindex index.html index.htm;\rlocation /europe {\ralias /usr/share/nginx/html/;\rindex index.html index.html;\r}\rlocation /asia {\ralias /usr/share/nginx/html/;\rindex index.html index.html;\r}\rlocation / {\rroot /usr/share/nginx/html;\rindex index.html index.htm;\r}\r}\r}\r---\rapiVersion: apps/v1\rkind: Deployment\rmetadata:\rlabels:\rapp: europe\rname: europe\rspec:\rprogressDeadlineSeconds: 600\rreplicas: 2\rrevisionHistoryLimit: 10\rselector:\rmatchLabels:\rapp: europe\rstrategy:\rrollingUpdate:\rmaxSurge: 25%\rmaxUnavailable: 25%\rtype: RollingUpdate\rtemplate:\rmetadata:\rcreationTimestamp: null\rlabels:\rapp: europe\rspec:\rcontainers:\r- image: nginx:1.21.5-alpine\rimagePullPolicy: IfNotPresent\rname: c\rresources: {}\rterminationMessagePath: /dev/termination-log\rterminationMessagePolicy: File\rvolumeMounts:\r- mountPath: /usr/share/nginx/html\rname: html\r- mountPath: /etc/nginx\rname: nginx-conf\rreadOnly: true\rdnsPolicy: ClusterFirst\rinitContainers:\r- command:\r- sh\r- -c\r- echo \u0026#39;hello, you reached EUROPE\u0026#39; \u0026gt; /html/index.html\rimage: busybox:1.28\rimagePullPolicy: IfNotPresent\rname: init-container\rresources: {}\rterminationMessagePath: /dev/termination-log\rterminationMessagePolicy: File\rvolumeMounts:\r- mountPath: /html\rname: html\rrestartPolicy: Always\rschedulerName: default-scheduler\rsecurityContext: {}\rterminationGracePeriodSeconds: 30\rvolumes:\r- emptyDir: {}\rname: html\r- configMap:\rdefaultMode: 420\ritems:\r- key: nginx.conf\rpath: nginx.conf\rname: nginx-conf\rname: nginx-conf\r---\rapiVersion: apps/v1\rkind: Deployment\rmetadata:\rlabels:\rapp: asia\rname: asia\rspec:\rprogressDeadlineSeconds: 600\rreplicas: 2\rrevisionHistoryLimit: 10\rselector:\rmatchLabels:\rapp: asia\rstrategy:\rrollingUpdate:\rmaxSurge: 25%\rmaxUnavailable: 25%\rtype: RollingUpdate\rtemplate:\rmetadata:\rcreationTimestamp: null\rlabels:\rapp: asia\rspec:\rcontainers:\r- image: nginx:1.21.5-alpine\rimagePullPolicy: IfNotPresent\rname: c\rresources: {}\rterminationMessagePath: /dev/termination-log\rterminationMessagePolicy: File\rvolumeMounts:\r- mountPath: /usr/share/nginx/html\rname: html\r- mountPath: /etc/nginx\rname: nginx-conf\rreadOnly: true\rdnsPolicy: ClusterFirst\rinitContainers:\r- command:\r- sh\r- -c\r- echo \u0026#39;hello, you reached ASIA\u0026#39; \u0026gt; /html/index.html\rimage: busybox:1.28\rimagePullPolicy: IfNotPresent\rname: init-container\rresources: {}\rterminationMessagePath: /dev/termination-log\rterminationMessagePolicy: File\rvolumeMounts:\r- mountPath: /html\rname: html\rrestartPolicy: Always\rschedulerName: default-scheduler\rsecurityContext: {}\rterminationGracePeriodSeconds: 30\rvolumes:\r- emptyDir: {}\rname: html\r- configMap:\rdefaultMode: 420\ritems:\r- key: nginx.conf\rpath: nginx.conf\rname: nginx-conf\rname: nginx-conf Il existe maintenant deux d√©ploiements dans le namespace par d√©faut √™tre rendus accessibles via une entr√©e.\nPremi√®rement : cr√©er des services LoadBalancer pour les deux d√©ploiements sur le port 30291 et 30292 et le target-port 80. Les services doivent porter le m√™me nom que les d√©ploiements.\n"},{"uri":"https://maxime-cls.github.io/kubernetes-tutorial/kubernetes/%C3%A9l%C3%A9mentaire/configmap/","title":"Configmap","tags":[],"description":"","content":"Pr√©requis Minikube Install Driver none kubectl Install Stern Docs Release jq Install 3 terminal SSH ConfigMap est la ressource Kubernetes qui vous permet d\u0026rsquo;externaliser la configuration de votre application.\nLa configuration d\u0026rsquo;une application est tout ce qui est susceptible de varier entre les d√©ploiements (staging, production, environnements de d√©veloppement, etc).\nThe Twelve-Factor App\nVariables d\u0026rsquo;environnement\nMyRESTController.java comprend un petit morceau de code qui s\u0026rsquo;adresse √† l\u0026rsquo;environnement :\n@RequestMapping(\u0026#34;/configure\u0026#34;)\rpublic String configure() {\rString databaseConn = environment.getProperty(\u0026#34;DBCONN\u0026#34;,\u0026#34;Default\u0026#34;);\rString msgBroker = environment.getProperty(\u0026#34;MSGBROKER\u0026#34;,\u0026#34;Default\u0026#34;);\rString hello = environment.getProperty(\u0026#34;GREETING\u0026#34;,\u0026#34;Default\u0026#34;);\rString love = environment.getProperty(\u0026#34;LOVE\u0026#34;,\u0026#34;Default\u0026#34;);\rreturn \u0026#34;Configuration: \\n\u0026#34;\r+ \u0026#34;databaseConn=\u0026#34; + databaseConn + \u0026#34;\\n\u0026#34;\r+ \u0026#34;msgBroker=\u0026#34; + msgBroker + \u0026#34;\\n\u0026#34;\r+ \u0026#34;hello=\u0026#34; + hello + \u0026#34;\\n\u0026#34;\r+ \u0026#34;love=\u0026#34; + love + \u0026#34;\\n\u0026#34;;\r} Les variables d\u0026rsquo;environnement peuvent √™tre manipul√©es au niveau du d√©ploiement. Les modifications entra√Ænent le red√©ploiement du Pod.\nD√©ploiement de myboot :\nCr√©er un fichier de d√©ploiement\nvi apps/kubefiles/myboot-deployment.yml myboot-deployment.yml\napiVersion: apps/v1\rkind: Deployment\rmetadata:\rlabels:\rapp: myboot\rname: myboot\rspec:\rreplicas: 1\rselector:\rmatchLabels:\rapp: myboot\rtemplate:\rmetadata:\rlabels:\rapp: myboot\rspec:\rcontainers:\r- name: myboot\rimage: quay.io/rhdevelopers/myboot:v2\rports:\r- containerPort: 8080 kubectl apply -f apps/kubefiles/myboot-deployment.yml D√©ployer le service myboot :\nvi apps/kubefiles/myboot-service.yml myboot-service.yml\napiVersion: v1\rkind: Service\rmetadata:\rname: myboot\rlabels:\rapp: myboot\rspec:\rports:\r- name: http\rport: 8080\rselector:\rapp: myboot\rtype: LoadBalancer kubectl apply -f apps/kubefiles/myboot-service.yml Et regardez l\u0026rsquo;√©tat du pod :\nwatch kubectl get pods Cr√©er les variables IP et PORT :\nIP=$(minikube ip -p devnation)\rPORT=$(kubectl get service/myboot -o jsonpath=\u0026#34;{.spec.ports[*].nodePort}\u0026#34;) R√©aliser une requete sur le service :\ncurl $IP:$PORT curl $IP:$PORT/configure Configuration for : myboot-66d7d57687-jsbz7\rdatabaseConn=Default\rmsgBroker=Default\rgreeting=Default\rlove=Default D√©finir les variables d\u0026rsquo;environnement\nkubectl set env deployment/myboot GREETING=\u0026#34;namaste\u0026#34;\rkubectl set env deployment/myboot LOVE=\u0026#34;Aloha\u0026#34;\rkubectl set env deployment/myboot DBCONN=\u0026#34;jdbc:sqlserver://45.91.12.123:1443;user=MyUserName;password=*****;\u0026#34; Regardez les pods reborn :\nNAME READY STATUS RESTARTS AGE\rmyboot-66d7d57687-jsbz7 1/1 Terminating 0 5m\rmyboot-785ff6bddc-ghwpc 1/1 Running 0 13s curl $IP:$PORT/configure Configuration for : myboot-5fd9dd9c59-58xbh\rdatabaseConn=jdbc:sqlserver://45.91.12.123:1443;user=MyUserName;password=*****;\rmsgBroker=Default\rgreeting=namaste\rlove=Aloha D√©crivez le d√©ploiement :\nkubectl describe deployment myboot ...\rContainers:\rmyboot:\rImage: quay.io/burrsutter/myboot:v1\rPort: 8080/TCP\rHost Port: 0/TCP\rEnvironment:\rGREETING: namaste\rLOVE: Aloha\rDBCONN: jdbc:sqlserver://45.91.12.123:1443;user=MyUserName;password=*****;\rMounts: \u0026lt;none\u0026gt;\rVolumes: \u0026lt;none\u0026gt;\r... Supprimez les variables d\u0026rsquo;environnement :\nkubectl set env deployment/myboot GREETING-\rkubectl set env deployment/myboot LOVE-\rkubectl set env deployment/myboot DBCONN- Et v√©rifiez qu\u0026rsquo;ils ont √©t√© retir√©s :\ncurl $IP:$PORT/configure Configuration for : myboot-66d7d57687-xkgw6\rdatabaseConn=Default\rmsgBroker=Default\rgreeting=Default\rlove=Default Cr√©er un ConfigMap\nkubectl create cm my-config --from-env-file=apps/config/some.properties kubectl get cm\rkubectl get cm my-config\rkubectl get cm my-config -o json ...\r\u0026#34;data\u0026#34;: {\r\u0026#34;GREETING\u0026#34;: \u0026#34;jambo\u0026#34;,\r\u0026#34;LOVE\u0026#34;: \u0026#34;Amour\u0026#34;\r},\r\u0026#34;kind\u0026#34;: \u0026#34;ConfigMap\u0026#34;,\r... Ou vous pouvez d√©crire l\u0026rsquo;objet ConfigMap :\nkubectl describe cm my-config Name: my-config\rNamespace: myspace\rLabels: \u0026lt;none\u0026gt;\rAnnotations: \u0026lt;none\u0026gt;\rData\r====\rGREETING:\r====\rjambo\rLOVE:\r====\rAmour\rEvents: \u0026lt;none\u0026gt; Maintenant, d√©ployez l\u0026rsquo;application avec sa requ√™te pour le ConfigMap :\nkubectl apply -f apps/kubefiles/myboot-deployment-configuration.yml Et obtenir son point de terminaison de configuration :\ncurl $IP:$PORT/configure Configuration for : myboot-84bfcff474-x6xnt\rdatabaseConn=Default\rmsgBroker=Default\rgreeting=jambo\rlove=Amour Et passez √† l\u0026rsquo;autre fichier de propri√©t√©s en recr√©ant le ConfigMap :\nkubectl delete cm my-config\rkubectl create cm my-config --from-env-file=apps/config/other.properties\rkubectl delete pod -l app=myboot curl $IP:$PORT/configure Configuration for : myboot-694954fc6d-nzdvx\rdatabaseConn=jdbc:sqlserver://123.123.123.123:1443;user=MyUserName;password=*****;\rmsgBroker=tcp://localhost:61616?jms.useAsyncSend=true\rhello=Default\rlove=Default Il y a beaucoup d\u0026rsquo;autres fa√ßons de s\u0026rsquo;amuser avec ConfigMaps, la documentation de base vous fait manipuler une sp√©cification Pod au lieu d\u0026rsquo;un d√©ploiement mais les r√©sultats sont fondamentalement les m√™mes https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap.\nSupprimer les ressources\nkubectl delete deployment myboot\rkubectl delete cm my-config\rkubectl delete service myboot A vous de jouez ! Votre objectif est de cr√©er un ConfigMap !\nCe ConfigMap doit :\nLa ressource doit port√©e le nom : trauerweide La configuration doit contenir : tree=trauerweide Voici le contenu du fichier cm.yaml\napiVersion: v1\rdata:\rtree: birke\rlevel: \u0026#34;3\u0026#34;\rdepartment: park\rkind: ConfigMap\rmetadata:\rname: birke "},{"uri":"https://maxime-cls.github.io/kubernetes-tutorial/kubernetes/d%C3%A9butant/logs/","title":"Logs","tags":[],"description":"","content":"Pr√©requis Minikube Install Driver none kubectl Install Stern Docs Release jq Install 3 terminal SSH Il existe plusieurs fa√ßons \u0026ldquo;pr√™tes √† la production\u0026rdquo; de collecter et de visualiser les messages de logs dans un cluster Kubernetes. Beaucoup de gens aiment certaines fonctionnalit√©s de ELK (ElasticSearch, Logstash, Kibana) ou EFK (ElasticSearch, FluentD, Kibana).\nL\u0026rsquo;accent est mis ici sur les √©l√©ments auxquels un d√©veloppeur doit avoir acc√®s pour l\u0026rsquo;aider √† comprendre le comportement de son application s\u0026rsquo;ex√©cutant √† l\u0026rsquo;int√©rieur d\u0026rsquo;un pod.\nAssurez-vous qu\u0026rsquo;une application (Deployment) est en cours d\u0026rsquo;ex√©cution :\ncat \u0026lt;\u0026lt;EOF | kubectl apply -f -\rapiVersion: apps/v1\rkind: Deployment\rmetadata:\rname: my-deployment\rspec:\rreplicas: 3\rselector:\rmatchLabels:\rapp: myapp\rtemplate:\rmetadata:\rlabels:\rapp: myapp\renv: dev\rspec:\rcontainers:\r- name: myapp\rimage: quay.io/rhdevelopers/myboot:v1\rimagePullPolicy: Always\rports:\r- containerPort: 8080\rEOF Assurez-vous que vous utilisez 3 r√©pliques (3 pods/instances de votre demande) :\nkubectl get deployment my-deployment -o json | jq \u0026#39;.status.replicas\u0026#39; If not, scale up to 3:\nkubectl scale --replicas=3 deployment/my-deployment NAME READY STATUS RESTARTS AGE\rmy-deployment-5dc67997c7-5bq4n 1/1 Running 0 34s\rmy-deployment-5dc67997c7-m7z9f 1/1 Running 0 34s\rmy-deployment-5dc67997c7-s4jc6 1/1 Running 0 34s kubectl logs my-deployment-5dc67997c7-m7z9f . ____ _ __ _ _\r/\\\\ / ___\u0026#39;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\\r( ( )\\___ | \u0026#39;_ | \u0026#39;_| | \u0026#39;_ \\/ _` | \\ \\ \\ \\\r\\\\/ ___)| |_)| | | | | || (_| | ) ) ) )\r\u0026#39; |____| .__|_| |_|_| |_\\__, | / / / /\r=========|_|==============|___/=/_/_/_/\r:: Spring Boot :: (v1.5.3.RELEASE) Vous pouvez suivre les logs avec le param√®tre -f :\nkubectl logs my-deployment-5dc67997c7-m7z9f -f terminal 2 :\nkubectl exec -it my-deployment-5dc67997c7-m7z9f /bin/bash\rcurl localhost:8080 Aloha from my-deployment-5dc67997c7-m7z9f Deploy a Service for my-deployment:\ncat \u0026lt;\u0026lt;EOF | kubectl apply -f -\rapiVersion: v1\rkind: Service\rmetadata:\rname: the-service\rspec:\rselector:\rapp: myapp\rports:\r- protocol: TCP\rport: 80\rtargetPort: 8080\rtype: LoadBalancer\rEOF terminal 2:\nIP=$(minikube ip)\rPORT=$(kubectl get service/the-service -o jsonpath=\u0026#34;{.spec.ports[*].nodePort}\u0026#34;) Curl the Service: terminal 2:\ncurl $IP:$PORT Commencez √† envoyer la demande en boucle : terminal 2:\nwhile true\rdo curl $IP:$PORT\rsleep .3\rdone Utilisez ensuite Stern pour visualiser les logs de tous les pods :\nstern my-deployment my-deployment-5dc67997c7-5bq4n myapp Aloha from my-deployment-5dc67997c7-5bq4n\rmy-deployment-5dc67997c7-m7z9f myapp Aloha from my-deployment-5dc67997c7-m7z9f\rmy-deployment-5dc67997c7-s4jc6 myapp Aloha from my-deployment-5dc67997c7-s4jc6\rmy-deployment-5dc67997c7-s4jc6 myapp Aloha from my-deployment-5dc67997c7-s4jc6 Nettoyer l\u0026rsquo;environnement\nkubectl delete service the-service\rkubectl delete deployment my-deployment "},{"uri":"https://maxime-cls.github.io/kubernetes-tutorial/kubernetes/intermediare/volumes/","title":"Volumes","tags":[],"description":"","content":"Pr√©requis Minikube Install Driver none kubectl Install Stern Docs Release jq Install 3 terminal SSH Les conteneurs sont √©ph√©m√®res par d√©finition, ce qui signifie que tout ce qui est stock√© au moment de l\u0026rsquo;ex√©cution est perdu lorsque le conteneur est arr√™t√©. Cela peut poser des probl√®mes avec les conteneurs qui ont besoin de conserver leurs donn√©es, comme les conteneurs de base de donn√©es.\nUn volume Kubernetes est simplement un r√©pertoire accessible aux conteneurs d\u0026rsquo;un pod. Le concept est similaire aux volumes Docker, mais dans Docker, vous faites correspondre le conteneur √† un ordinateur h√¥te. Dans le cas des volumes Kubernetes, le support qui le soutient et son contenu sont d√©termin√©s par le type de volume particulier utilis√©.\nCertains de ces types de volumes sont :\nawsElasticBlockStore azureDisk cephfs nfs local r√©pertoire vide chemin de l\u0026rsquo;h√¥te Commen√ßons par deux exemples de Volumes.\nVolumes EmptyDir Un volume emptyDir est cr√©√© pour la premi√®re fois lorsqu\u0026rsquo;un Pod est affect√© √† un n≈ìud et existe tant que ce Pod fonctionne sur ce n≈ìud. Comme son nom l\u0026rsquo;indique, il est initialement vide. Tous les conteneurs d\u0026rsquo;un m√™me pod peuvent lire et √©crire dans le m√™me volume emptyDir. Lorsqu\u0026rsquo;un Pod est red√©marr√© ou supprim√©, les donn√©es contenues dans le volume \u0026ldquo;emptyDir\u0026rdquo; sont perdues √† jamais.\nD√©ployons un service qui expose deux points de terminaison, l\u0026rsquo;un pour √©crire du contenu dans un fichier et l\u0026rsquo;autre pour r√©cup√©rer le contenu de ce fichier.\nvim apps/kubefiles/myboot-pod-volume.yml apiVersion: v1\rkind: Pod\rmetadata:\rname: myboot-demo\rspec:\rcontainers:\r- name: myboot-demo\rimage: quay.io/rhdevelopers/myboot:v4\rvolumeMounts:\r- mountPath: /tmp/demo\rname: demo-volume\rvolumes:\r- name: demo-volume\remptyDir: {} Dans la section volumes, vous d√©finissez le volume, et dans la section volumeMounts, comment le volume est mont√© √† l\u0026rsquo;int√©rieur du conteneur.\nkubectl apply -f apps/kubefiles/myboot-pod-volume.yml\rkubectl get pods NAME READY STATUS RESTARTS AGE\rmyboot-demo 1/1 Running 0 83s Acc√©dons au conteneur et ex√©cutons ces m√©thodes :\nkubectl exec -ti myboot-demo /bin/bash\rcurl localhost:8080/appendgreetingfile\rcurl localhost:8080/readgreetingfile Jambo Dans ce cas, le emptyDir a √©t√© d√©fini √† /tmp/demo, vous pouvez donc v√©rifier le contenu du r√©pertoire en ex√©cutant ls :\nls /tmp/demo greeting.txt Quitter le shell du conteneur :\nexit Et supprimez le pod.\nkubectl delete pod myboot-demo Ensuite, si vous d√©ployez √† nouveau le m√™me service, vous remarquerez que le contenu du r√©pertoire est vide.\nkubectl exec -ti myboot-demo /bin/bash\rls /tmp/demo\rexit Et supprimez le pod.\nkubectl delete pod myboot-demo emptyDir est partag√© entre les conteneurs d\u0026rsquo;un m√™me Pod. Le d√©ploiement suivant cr√©e un pod avec deux conteneurs montant le m√™me volume :\nvim apps/kubefiles/myboot-pods-volume.yml apiVersion: v1\rkind: Pod\rmetadata:\rname: myboot-demo\rspec:\rcontainers:\r- name: myboot-demo-1 #\u0026lt;.\u0026gt;\rimage: quay.io/rhdevelopers/myboot:v4\rvolumeMounts:\r- mountPath: /tmp/demo\rname: demo-volume\r- name: myboot-demo-2 #\u0026lt;.\u0026gt;\rimage: quay.io/rhdevelopers/myboot:v4 #\u0026lt;.\u0026gt;\renv:\r- name: SERVER_PORT #\u0026lt;.\u0026gt;\rvalue: \u0026#34;8090\u0026#34;\rvolumeMounts:\r- mountPath: /tmp/demo\rname: demo-volume\rvolumes:\r- name: demo-volume #\u0026lt;.\u0026gt;\remptyDir: {} kubectl apply -f apps/kubefiles/myboot-pods-volume.yml\rkubectl get pods NAME READY STATUS RESTARTS AGE\rmyboot-demo 2/2 Running 0 4s Acc√©dons au premier conteneur et g√©n√©rons du contenu dans le r√©pertoire /tmp/demo.\nkubectl exec -ti myboot-demo -c myboot-demo-1 /bin/bash\rcurl localhost:8080/appendgreetingfile\rexit Et lire le contenu du fichier dans l\u0026rsquo;autre conteneur :\nkubectl exec myboot-demo -c myboot-demo-2 \u0026#34;cat /tmp/demo/greeting.txt\u0026#34; Jambo Vous pouvez obtenir les informations sur le volume d\u0026rsquo;un Pod en ex√©cutant :\nkubectl describe pod myboot-demo Volumes:\rdemo-volume:\rType: EmptyDir (a temporary directory that shares a pods lifetime)\rMedium:\rSizeLimit: \u0026lt;unset\u0026gt; Supprimer les ressources\nkubectl delete -f apps/kubefiles/myboot-pods-volume.yml HostPath Un volume hostPath monte un fichier ou un r√©pertoire du syst√®me de fichiers du n≈ìud dans le Pod.\nvim apps/kubefiles/myboot-pod-volume-hostpath.yaml apiVersion: v1\rkind: Pod\rmetadata:\rname: myboot-demo\rspec:\rcontainers:\r- name: myboot-demo\rimage: quay.io/rhdevelopers/myboot:v4\rvolumeMounts:\r- mountPath: /tmp/demo\rname: demo-volume\rvolumes:\r- name: demo-volume\rhostPath:\rpath: \u0026#34;/mnt/data\u0026#34; Dans ce cas, vous d√©finissez le r√©pertoire de l\u0026rsquo;h√¥te/n≈ìud o√π le contenu sera stock√©.\nkubectl apply -f apps/kubefiles/myboot-pod-volume-hostpath.yaml Maintenant, si vous d√©crivez le Pod, dans la section des volumes, vous verrez :\nkubectl describe pod myboot-demo Volumes:\rdemo-volume:\rType: HostPath (bare host directory volume)\rPath: /mnt/data\rHostPathType: Notez que maintenant le contenu stock√© dans /tmp/demo √† l\u0026rsquo;int√©rieur du Pod est stock√© dans le chemin de l\u0026rsquo;h√¥te /mnt/data, donc si le Pod meurt, le contenu n\u0026rsquo;est pas perdu. Mais cela ne r√©sout pas tous les probl√®mes car si le Pod tombe en panne et qu\u0026rsquo;il est reprogramm√© dans un autre n≈ìud, les donn√©es ne seront pas dans cet autre n≈ìud.\nVoyons un autre exemple, dans ce cas pour un volume Amazon EBS :\napiVersion: v1\rkind: Pod\rmetadata:\rname: test-ebs\rspec:\r...\rvolumes:\r- name: test-volume\rawsElasticBlockStore:\rvolumeID: \u0026lt;volume-id\u0026gt;\rfsType: ext4 Ce que nous voulons que vous remarquiez dans l\u0026rsquo;extrait pr√©c√©dent, c\u0026rsquo;est que vous m√©langez des √©l√©ments de votre application (c\u0026rsquo;est-√†-dire le conteneur, les sondes, les ports, \u0026hellip;) qui sont plus du c√¥t√© du d√©veloppement avec des √©l√©ments plus li√©s au cloud (c\u0026rsquo;est-√†-dire le stockage physique), qui est plus du c√¥t√© des op√©rations.\nPour √©viter ce m√©lange de concepts, Kubernetes offre une certaine couche d\u0026rsquo;abstractions, de sorte que les d√©veloppeurs demandent simplement de l\u0026rsquo;espace pour stocker les donn√©es (-persistent volume claim_), et l\u0026rsquo;√©quipe des op√©rations offre la configuration du stockage physique.\nSupprimer les ressources\nkubectl delete pod myboot-demo Persistent Volume \u0026amp; Persistent Volume Claim Un PersistentVolume (PV) est une ressource Kubernetes qui est cr√©√©e par un administrateur ou dynamiquement √† l\u0026rsquo;aide de Storage Classes ind√©pendamment de Pod. Il capture les d√©tails de l\u0026rsquo;impl√©mentation du stockage, il peut s\u0026rsquo;agir de NFS, Ceph, iSCSI, ou d\u0026rsquo;un syst√®me de stockage sp√©cifique au fournisseur de cloud.\nUne PersistentVolumeClaim (PVC) est une demande de stockage par un utilisateur. Il peut demander une taille de volume sp√©cifique ou, par exemple, le mode d\u0026rsquo;acc√®s.\nVolume persistant/claim avec hostPath Utilisons la strat√©gie hostPath sans la configurer directement en tant que volume, mais en utilisant le volume persistant et la r√©clamation de volume persistant.\nvim apps/kubefiles/demo-persistent-volume-hostpath.yaml kind: PersistentVolume\rapiVersion: v1\rmetadata:\rname: my-persistent-volume\rlabels:\rtype: local\rspec:\rstorageClassName: pv-demo\rcapacity:\rstorage: 100Mi\raccessModes:\r- ReadWriteOnce\rhostPath:\rpath: \u0026#34;/mnt/persistent-volume\u0026#34; D√©sormais, les informations relatives au volume ne se trouvent plus dans le pod mais dans l\u0026rsquo;objet volume persistant.\nkubectl apply -f apps/kubefiles/demo-persistent-volume-hostpath.yaml\rkubectl get pv NAME CAPACITY ACCESS MODES RECLAIM POLICY STATUS CLAIM STORAGECLASS REASON AGE\rmy-persistent-volume 100Mi RWO Retain Available pv-demo 5s Ensuite, du c√¥t√© du d√©veloppeur, nous devons r√©clamer ce dont nous avons besoin sur le PV. Dans l\u0026rsquo;exemple suivant, nous demandons un espace de 10Mi.\nvim apps/kubefiles/myboot-persistent-volume-claim.yaml kind: PersistentVolumeClaim\rapiVersion: v1\rmetadata:\rname: myboot-volumeclaim\rspec:\rstorageClassName: pv-demo\raccessModes:\r- ReadWriteOnce\rresources:\rrequests:\rstorage: 10Mi kubectl apply -f apps/kubefiles/myboot-persistent-volume-claim.yaml\rkubectl get pvc NAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS AGE\rmyboot-volumeclaim Bound my-persistent-volume 100Mi RWO pv-demo 3s La grande diff√©rence est que maintenant, dans le pod, vous d√©finissez simplement dans la section volumes, non pas la configuration du volume directement, mais la revendication du volume persistant √† utiliser.\nvim apps/kubefiles/myboot-pod-volume-pvc.yaml apiVersion: v1\rkind: Pod\rmetadata:\rname: myboot-demo\rspec:\rcontainers:\r- name: myboot-demo\rimage: quay.io/rhdevelopers/myboot:v4\rvolumeMounts:\r- mountPath: /tmp/demo\rname: demo-volume\rvolumes:\r- name: demo-volume\rpersistentVolumeClaim:\rclaimName: myboot-volumeclaim kubectl apply -f apps/kubefiles/myboot-pod-volume-pvc.yaml\rkubectl describe pod myboot-demo Volumes:\rdemo-volume:\rType: PersistentVolumeClaim (a reference to a PersistentVolumeClaim in the same namespace)\rClaimName: myboot-volumeclaim\rReadOnly: false Remarquez que maintenant la description du pod montre que le volume n\u0026rsquo;est pas d√©fini directement mais par le biais d\u0026rsquo;une r√©clamation de volume de persistance.\nkubectl delete pod myboot-demo\rkubectl get pvc M√™me si le pod a √©t√© supprim√©, le PVC (et le PV) sont toujours l√† et doivent √™tre supprim√©s manuellement.\nNAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS AGE\rmyboot-volumeclaim Bound my-persistent-volume 100Mi RWO pv-demo 14m Supprimer les ressources\nkubectl delete -f apps/kubefiles/myboot-persistent-volume-claim.yaml\rkubectl delete -f apps/kubefiles/demo-persistent-volume-hostpath.yaml Provisonnement Statique vs Dynamique Les Persistent Volumes peuvent √™tre provisionn√©s de mani√®re dynamique ou statique.\nLe provisionnement statique permet aux administrateurs de clusters de mettre √† disposition d\u0026rsquo;un cluster une unit√© de stockage existante. Lorsqu\u0026rsquo;il est effectu√© de cette mani√®re, le PV et le PVC doivent √™tre fournis manuellement.\nJusqu\u0026rsquo;√† pr√©sent, dans le dernier exemple, vous avez vu le provisionnement statique.\nAvec le provisionnement dynamique, les administrateurs de clusters n\u0026rsquo;ont plus besoin de pr√©-provisionner le stockage. Au lieu de cela, il provisionne automatiquement le stockage lorsqu\u0026rsquo;il est demand√© par les utilisateurs. Pour le faire fonctionner, vous devez fournir un objet Storage Class et un PVC s\u0026rsquo;y r√©f√©rant. Une fois le PVC cr√©√©, le p√©riph√©rique de stockage et le PV sont automatiquement cr√©√©s pour vous. L\u0026rsquo;objectif principal du provisionnement dynamique est de travailler avec des solutions de fournisseurs de cloud.\nNormalement, l\u0026rsquo;impl√©mentation de Kubernetes propose une classe de stockage par d√©faut afin que chacun puisse d√©marrer rapidement avec le provisionnement dynamique. Vous pouvez obtenir des informations sur la classe de stockage par d√©faut en ex√©cutant :\nkubectl get sc NAME PROVISIONER RECLAIMPOLICY VOLUMEBINDINGMODE ALLOWVOLUMEEXPANSION AGE\rstandard (default) k8s.io/minikube-hostpath Delete Immediate false 47d Ensuite, vous pouvez cr√©er une r√©clamation de volume persistant qui cr√©era automatiquement un volume persistant.\nvim apps/kubefiles/demo-dynamic-persistent.yaml kind: PersistentVolumeClaim\rapiVersion: v1\rmetadata:\rname: myboot-volumeclaim\rspec:\raccessModes:\r- ReadWriteOnce\rresources:\rrequests:\rstorage: 10Mi Puisque nous n\u0026rsquo;avons pas sp√©cifi√© de classe de stockage mais qu\u0026rsquo;il y en a une d√©finie par d√©faut, le PVC se r√©f√®re implicitement √† celle-ci.\nkubectl apply -f apps/kubefiles/demo-dynamic-persistent.yaml\rkubectl get pvc NAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS AGE\rmyboot-volumeclaim Pending gp2 46s√ß Remarquez que le PVC est en √©tat d\u0026rsquo;attente, car rappelez-vous que nous cr√©ons un stockage dynamique et que cela signifie que tant que le pod ne demande pas le volume, le PVC restera en √©tat d\u0026rsquo;attente et le PV ne sera pas cr√©√©.\nkubectl apply -f apps/kubefiles/myboot-pod-volume-pvc.yaml\rkubectl get pods NAME READY STATUS RESTARTS AGE\rmyboot-demo 1/1 Running 0 2m36s Lorsque le pod est en √©tat de fonctionnement, vous pouvez obtenir les param√®tres PVC et PV.\nkubectl get pvc NAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS AGE\rmyboot-volumeclaim Bound pvc-6de4f27e-bd40-4b58-bb46-91eb08ca5bd7 1Gi RWO gp2 116s Remarquez que maintenant la demande de volume est li√©e √† un volume.\nEnfin, vous pouvez v√©rifier que le PV a √©t√© cr√©√© automatiquement :\nkubectl get pv\nNAME CAPACITY ACCESS MODES RECLAIM POLICY STATUS CLAIM STORAGECLASS REASON AGE\rpvc-6de4f27e-bd40-4b58-bb46-91eb08ca5bd7 1Gi RWO Delete Bound default/myboot-volumeclaim gp2 77s Notez que le champ CLAIM pointe vers le PVC responsable de la cr√©ation du PV.\nSupprimer les ressources\nkubectl delete -f apps/kubefiles/myboot-pod-volume-pvc.yaml\rkubectl delete -f apps/kubefiles/demo-dynamic-persistent.yaml Syst√®mes de fichiers distribu√©s Il est important de noter que les fournisseurs de cloud computing proposent des stockages distribu√©s afin que les donn√©es soient toujours disponibles dans tous les n≈ìuds. Comme vous l\u0026rsquo;avez vu dans le dernier exemple, cette classe de stockage garantit que tous les n≈ìuds voient le m√™me contenu de disque.\nSi par exemple, vous utilisez Kubernetes on-prem ou si vous ne voulez pas relayer vers une solution fournisseur, il existe √©galement une prise en charge des syst√®mes de fichiers distribu√©s dans Kubernetes. Si c\u0026rsquo;est le cas, nous vous recommandons d\u0026rsquo;utiliser NFS, GlusterFS ou Ceph.\n"},{"uri":"https://maxime-cls.github.io/kubernetes-tutorial/kubernetes/%C3%A9l%C3%A9mentaire/","title":"Elementaire","tags":[],"description":"","content":""},{"uri":"https://maxime-cls.github.io/kubernetes-tutorial/kubernetes/d%C3%A9butant/servicemagic/","title":"Service Magic","tags":[],"description":"","content":"Pr√©requis Minikube Install Driver none kubectl Install Stern Docs Release jq Install 3 terminal SSH Cr√©er un namespace\nkubectl create namespace funstuff\rkubectl config set-context --current --namespace=funstuff Deployer une application mypython\ncat \u0026lt;\u0026lt;EOF | kubectl apply -f -\rapiVersion: apps/v1\rkind: Deployment\rmetadata:\rname: mypython-deployment\rspec:\rreplicas: 1\rselector:\rmatchLabels:\rapp: mypython\rtemplate:\rmetadata:\rlabels:\rapp: mypython\rspec:\rcontainers:\r- name: mypython\rimage: quay.io/rhdevelopers/mypython:v1\rports:\r- containerPort: 8000\rEOF Deployer une application mygo\ncat \u0026lt;\u0026lt;EOF | kubectl apply -f -\rapiVersion: apps/v1\rkind: Deployment\rmetadata:\rname: mygo-deployment\rspec:\rreplicas: 1\rselector:\rmatchLabels:\rapp: mygo\rtemplate:\rmetadata:\rlabels:\rapp: mygo\rspec:\rcontainers:\r- name: mygo\rimage: quay.io/rhdevelopers/mygo:v1\rports:\r- containerPort: 8000\rEOF Deployer une application mynode\ncat \u0026lt;\u0026lt;EOF | kubectl apply -f -\rapiVersion: apps/v1\rkind: Deployment\rmetadata:\rname: mynode-deployment\rspec:\rreplicas: 1\rselector:\rmatchLabels:\rapp: mynode\rtemplate:\rmetadata:\rlabels:\rapp: mynode\rspec:\rcontainers:\r- name: mynode\rimage: quay.io/rhdevelopers/mynode:v1\rports:\r- containerPort: 8000\rEOF V√©rifier l\u0026rsquo;√©tat des applications\nwatch kubectl get pods --show-labels NAME READY STATUS RESTARTS AGE LABELS\rmygo-deployment-6d944c5c69-kcvmk 1/1 Running 0 2m11s app=mygo,pod-template-hash=6d944c5c69\rmynode-deployment-fb5457c5-hhz7h 1/1 Running 0 2m1s app=mynode,pod-template-hash=fb5457c5\rmypython-deployment-6874f84d85-2kpjl 1/1 Running 0 3m53s app=mypython,pod-template-hash=6874f84d85 D√©ployer un service g√©n√©rique\ncat \u0026lt;\u0026lt;EOF | kubectl apply -f -\rapiVersion: v1\rkind: Service\rmetadata:\rname: my-service\rlabels:\rapp: mystuff\rspec:\rports:\r- name: http\rport: 8000\rselector:\rinservice: mypods\rtype: LoadBalancer\rEOF Observer la description de ce service\nkubectl describe service my-service Observer la pr√©sence de EndPoint\nkubectl get endpoints NAME ENDPOINTS AGE\rmy-service \u0026lt;none\u0026gt; 2m6s Recherche l\u0026rsquo;adresse IP du EndPoint\nkubectl get endpoints my-service -o json | jq \u0026#39;.subsets[].addresses[].ip\u0026#39; jq: error (at \u0026lt;stdin\u0026gt;:18): Cannot iterate over null (null) D√©finir les variables IP et PORT\nIP=$(minikube ip)\rPORT=$(kubectl get service/my-service -o jsonpath=\u0026#34;{.spec.ports[*].nodePort}\u0026#34;) Faire une requete au service\ncurl $IP:$PORT Faire une boucle de requete au service\nwhile true\rdo curl $IP:$PORT\rsleep .3\rdone curl: (7) Failed to connect to 35.224.233.213 port 8000: Connection refused\rcurl: (7) Failed to connect to 35.224.233.213 port 8000: Connection refused Ajouter un label √† un pod\nkubectl label pod -l app=mypython inservice=mypods curl: (7) Failed to connect to 35.224.233.213 port 8000: Connection refused\rPython Hello on mypython-deployment-6874f84d85-2kpjl\rPython Hello on mypython-deployment-6874f84d85-2kpjl\rPython Hello on mypython-deployment-6874f84d85-2kpjl kubectl label pod -l app=mynode inservice=mypods Python Hello on mypython-deployment-6874f84d85-2kpjl\rPython Hello on mypython-deployment-6874f84d85-2kpjl\rNode Hello on mynode-deployment-fb5457c5-hhz7h 0\rNode Hello on mynode-deployment-fb5457c5-hhz7h 1\rPython Hello on mypython-deployment-6874f84d85-2kpjl\rPython Hello on mypython-deployment-6874f84d85-2kpjl\rPython Hello on mypython-deployment-6874f84d85-2kpjl kubectl label pod -l app=mygo inservice=mypods Node Hello on mynode-deployment-fb5457c5-hhz7h 59\rNode Hello on mynode-deployment-fb5457c5-hhz7h 60\rGo Hello on mygo-deployment-6d944c5c69-kcvmk\rPython Hello on mypython-deployment-6874f84d85-2kpjl\rPython Hello on mypython-deployment-6874f84d85-2kpjl Recherche les IP du EndPoint\nkubectl get endpoints my-service -o json | jq \u0026#39;.subsets[].addresses[].ip\u0026#39; \u0026#34;10.130.2.43\u0026#34;\r\u0026#34;10.130.2.44\u0026#34;\r\u0026#34;10.130.2.45\u0026#34; Afficher les pods avec les labels\nkubectl get pods -o wide Supprimer l\u0026rsquo;application mypython du service\nkubectl label pod -l app=mypython inservice- kubectl get endpoints my-service -o json | jq \u0026#39;.subsets[].addresses[].ip\u0026#39;- \u0026#34;10.130.2.44\u0026#34;\r\u0026#34;10.130.2.45\u0026#34; Supprimer le namespace\nkubectl delete namespace funstuff "},{"uri":"https://maxime-cls.github.io/kubernetes-tutorial/kubernetes/intermediare/","title":"Intermediare","tags":[],"description":"","content":""},{"uri":"https://maxime-cls.github.io/kubernetes-tutorial/kubernetes/d%C3%A9butant/blue-green/","title":"D√©ploiement Blue/Green","tags":[],"description":"","content":"Pr√©requis Minikube Install Driver none kubectl Install Stern Docs Release jq Install 3 terminal SSH Cr√©er un namespace\nkubectl create namespace myspace\rkubectl config set-context --current --namespace=myspace V√©rifier que le namespace est vide\nkubectl get all No resources found in myspace namespace. Cr√©er un fichier de d√©ploiement\nmkdir -p apps/kubefiles/\rvi apps/kubefiles/myboot-deployment-resources-limits.yml myboot-deployment-resources-limits.yml\napiVersion: apps/v1\rkind: Deployment\rmetadata:\rlabels:\rapp: myboot\rname: myboot\rspec:\rreplicas: 1\rselector:\rmatchLabels:\rapp: myboot\rtemplate:\rmetadata:\rlabels:\rapp: myboot\rspec:\rcontainers:\r- name: myboot\rimage: quay.io/rhdevelopers/myboot:v1\rports:\r- containerPort: 8080\rresources:\rrequests:\rmemory: \u0026#34;300Mi\u0026#34;\rcpu: \u0026#34;250m\u0026#34; # 1/4 core\r# NOTE: These are the same limits we tested our Docker Container with earlier\r# -m matches limits.memory and --cpus matches limits.cpu\rlimits:\rmemory: \u0026#34;400Mi\u0026#34;\rcpu: \u0026#34;1000m\u0026#34; # 1 core D√©ployer la version 1 de l\u0026rsquo;applciation myboot\nkubectl apply -f apps/kubefiles/myboot-deployment-resources-limits.yml Scale l\u0026rsquo;application avec 2 replicas\nkubectl scale deployment/myboot --replicas=2 V√©rifier l\u0026rsquo;√©tat de l\u0026rsquo;application\nwatch kubectl get pods --show-labels Cr√©er un fichier pour votre service\nvi apps/kubefiles/myboot-service.yml myboot-service.yml\napiVersion: v1\rkind: Service\rmetadata:\rname: myboot\rlabels:\rapp: myboot\rspec:\rports:\r- name: http\rport: 8080\rselector:\rapp: myboot\rtype: LoadBalancer D√©ployer le service\nkubectl apply -f apps/kubefiles/myboot-service.yml Cr√©er les variables d\u0026rsquo;environnement IP et Port\nIP=$(minikube ip)\rPORT=$(kubectl get service/myboot -o jsonpath=\u0026#34;{.spec.ports[*].nodePort}\u0026#34;) R√©aliser une requete du service\ncurl $IP:$PORT Et maintenant cr√©er une boucle de requete\nwhile true\rdo curl $IP:$PORT\rsleep .3\rdone Cr√©er un fichier de d√©ploiement pour la version 2\nvi apps/kubefiles/myboot-deployment-resources-limits-v2.yml myboot-deployment-resources-limits-v2.yml\napiVersion: apps/v1\rkind: Deployment\rmetadata:\rlabels:\rapp: myboot-next\rname: myboot-next-5\rspec:\rreplicas: 1\rselector:\rmatchLabels:\rapp: myboot-next\rtemplate:\rmetadata:\rlabels:\rapp: myboot-next\rspec:\rcontainers:\r- name: myboot\rimage: quay.io/rhdevelopers/myboot:v3\rports:\r- containerPort: 8080\rresources:\rrequests:\rmemory: \u0026#34;300000Mi\u0026#34;\rcpu: \u0026#34;250m\u0026#34; # 1/4 core\rlimits:\rmemory: \u0026#34;900000Mi\u0026#34;\rcpu: \u0026#34;1000m\u0026#34; # 1 core D√©ployer la version 2 de l\u0026rsquo;applciation myboot\nkubectl apply -f apps/kubefiles/myboot-deployment-resources-limits-v2.yml V√©rifiez que le nouveau pod/d√©ploiement porte le nouveau code :\nPODNAME=$(kubectl get pod -l app=myboot-next -o name)\rkubectl exec -it $PODNAME -- curl localhost:8080 Bonjour from Spring Boot! 1 on myboot-next-66b68c6659-ftcjr Maintenant, mettez √† jour le service unique pour pointer vers le nouveau pod et passez au Green :\nkubectl patch svc/myboot -p \u0026#39;{\u0026#34;spec\u0026#34;:{\u0026#34;selector\u0026#34;:{\u0026#34;app\u0026#34;:\u0026#34;myboot-next\u0026#34;}}}\u0026#39; Aloha from Spring Boot! 240 on myboot-d78fb6d58-929wn\rBonjour from Spring Boot! 2 on myboot-next-66b68c6659-ftcjr\rBonjour from Spring Boot! 3 on myboot-next-66b68c6659-ftcjr\rBonjour from Spring Boot! 4 on myboot-next-66b68c6659-ftcjr Vous d√©terminez que vous pr√©f√©rez l\u0026rsquo;hawa√Øen (bleu) au fran√ßais (vert) et faites un rollback :\nMettez maintenant √† jour le service unique pour pointer vers le nouveau pod et passez en Bleu :\nkubectl patch svc/myboot -p \u0026#39;{\u0026#34;spec\u0026#34;:{\u0026#34;selector\u0026#34;:{\u0026#34;app\u0026#34;:\u0026#34;myboot\u0026#34;}}}\u0026#39; Bonjour from Spring Boot! 17 on myboot-next-66b68c6659-ftcjr\rAloha from Spring Boot! 257 on myboot-d78fb6d58-vqvlb\rAloha from Spring Boot! 258 on myboot-d78fb6d58-vqvlb Supprimer les ressources\nkubectl delete service myboot\rkubectl delete deployment myboot\rkubectl delete deployment myboot-next A vous de jouer ! Effectuer un d√©ploiement Green-Blue d\u0026rsquo;une application.\nD√©ployer l\u0026rsquo;application suivante :\napiVersion: apps/v1\rkind: Deployment\rmetadata:\rlabels:\rapp: wonderful\rname: wonderful-v1\rspec:\rreplicas: 4\rselector:\rmatchLabels:\rapp: wonderful\rversion: v1\rtemplate:\rmetadata:\rlabels:\rapp: wonderful\rversion: v1\rspec:\rcontainers:\r- image: httpd:alpine\rname: httpd\r---\rapiVersion: v1\rkind: Service\rmetadata:\rlabels:\rapp: wonderful\rname: wonderful\rspec:\rports:\r- port: 30290\rprotocol: TCP\rtargetPort: 80\rselector:\rapp: wonderful\rversion: v1\rtype: LoadBalancer L\u0026rsquo;application \u0026ldquo;wonderful\u0026rdquo; est ex√©cut√©e dans le namespace par d√©faut.\nCr√©er les variables d\u0026rsquo;environnement IP et Port\nIP=$(minikube ip)\rPORT=$(kubectl get service/wonderful -o jsonpath=\u0026#34;{.spec.ports[*].nodePort}\u0026#34;) Vous pouvez appeler l\u0026rsquo;application en utilisant curl $IP:$PORT .\nEt maintenant cr√©er une boucle de requete\nwhile true\rdo curl $IP:$PORT\rsleep .3\rdone L\u0026rsquo;application a un d√©ploiement avec l\u0026rsquo;image httpd:alpine , mais devrait √™tre bascul√©e sur nginx:alpine .\nLe basculement doit se faire instantan√©ment. Cela signifie qu\u0026rsquo;√† partir du moment o√π l\u0026rsquo;application est d√©ploy√©e, toutes les nouvelles requ√™tes doivent utiliser la nouvelle image.\nCr√©er un nouveau Deployment wonderful-v2 qui utilise l\u0026rsquo;image nginx:alpine avec 4 r√©pliques. Ses Pods doivent avoir les labels app : wonderful et version : v2.\nUne fois que tous les nouveaux Pods sont en cours d\u0026rsquo;ex√©cution, changez l\u0026rsquo;√©tiquette du s√©lecteur du Service wonderful en version : v2.\nEnfin, r√©duire le d√©ploiement wonderful-v1 √† 0 r√©plicas.\n"},{"uri":"https://maxime-cls.github.io/kubernetes-tutorial/kubernetes/intermediare/taints_affinity/","title":"Taints et Affinity","tags":[],"description":"","content":"Pr√©requis Minikube Install Driver none kubectl Install Stern Docs Release jq Install 3 terminal SSH Jusqu\u0026rsquo;√† pr√©sent, lorsque nous d√©ployions un Pod dans le cluster Kubernetes, il √©tait ex√©cut√© sur n\u0026rsquo;importe quel n≈ìud r√©pondant aux exigences (c\u0026rsquo;est-√†-dire les exigences en mati√®re de m√©moire, de CPU, \u0026hellip;).\nCependant, dans Kubernetes, il existe deux concepts qui vous permettent de configurer davantage le planificateur, de sorte que les pods soient affect√©s aux n≈ìuds en fonction de certains crit√®res commerciaux.\nPreparation Si vous ex√©cutez ce tutoriel dans Minikube, vous devez d√©ployer un premier noeud en utilisant le driver docker :\nminikube stop\rminikube delete --all\rminikube start --driver=docker Si vous avez un proxy\nminikube stop\rminikube delete --all\rminikube start --docker-env HTTPS_PROXY=$HTTPS_PROXY --docker-env HTTP_PROXY=$HTTP_PROXY --docker-env=NO_PROXY=$no_proxy Ajouter des n≈ìuds suppl√©mentaires pour ex√©cuter cette partie du tutoriel. V√©rifiez le nombre de n≈ìuds que vous avez delpoy√©s en ex√©cutant :\nkubectl get nodes Si un seul n≈ìud est pr√©sent, vous devez cr√©er un nouveau n≈ìud en suivant les √©tapes suivantes :\nNAME STATUS ROLES AGE VERSION\rkube Ready master 54m v1.23.1 Ayant minikube install√© et dans votre PATH, puis ex√©cutez :\nminikube node add kubectl get nodes NAME STATUS ROLES AGE VERSION\rkube Ready master 54m v1.23.1\rkube-m02 Ready \u0026lt;none\u0026gt; 2m50s v1.23.1 Taints et Tol√©rance Une taint est appliqu√©e √† un n≈ìud Kubernetes qui signale au planificateur d\u0026rsquo;√©viter ou de ne pas planifier certains pods.\nUne tol√©rance est appliqu√©e √† la d√©finition d\u0026rsquo;un pod et fournit une exception au taint.\nD√©crivons les n≈ìuds actuels, dans ce cas comme un cluster Minikube est utilis√©, vous pouvez voir plusieurs n≈ìuds :\nkubectl describe nodes | egrep \u0026#34;Name:|Taints:\u0026#34; Name: minikube\rTaints: \u0026lt;none\u0026gt;\rName: minikube-m02\rTaints: \u0026lt;none\u0026gt; Notez que dans ce cas, les n≈ìuds ne contient pas de taint.\nTaints Ajoutons une tache √† tous les noeuds :\nkubectl taint nodes --all=true color=blue:NoSchedule node/minikube tainted\rnode/minikube-m02 tainted La couleur=bleue est simplement une paire cl√©=valeur pour identifier la taint et NoSchedule est l\u0026rsquo;effet sp√©cifique.\nMaintenant, d√©ployez un nouveau pod.\nvim apps/kubefiles/myboot-nginx-deployment.yml apiVersion: apps/v1\rkind: Deployment\rmetadata:\rlabels:\rapp: myboot\rname: myboot\rspec:\rreplicas: 1\rselector:\rmatchLabels:\rapp: myboot\rtemplate:\rmetadata:\rlabels:\rapp: myboot\rspec:\rcontainers:\r- name: myboot\rimage: nginx\rports:\r- containerPort: 8080 kubectl apply -f apps/kubefiles/myboot-nginx-deployment.yml\rkubectl get pods Le pod restera en statut Pending car il n\u0026rsquo;a pas de n≈ìud programmable disponible.\nNAME READY STATUS RESTARTS AGE\rmyboot-7f889dd6d-n5z55 0/1 Pending 0 55s kubectl describe pod myboot-7f889dd6d-n5z55 Name: myboot-7f889dd6d-n5z55\rNamespace: kubetut\rPriority: 0\rNode: \u0026lt;none\u0026gt;\rLabels: app=myboot\rpod-template-hash=7f889dd6d\rAnnotations: openshift.io/scc: restricted\rStatus: Pending\rNode-Selectors: \u0026lt;none\u0026gt;\rTolerations: node.kubernetes.io/not-ready:NoExecute for 300s\rnode.kubernetes.io/unreachable:NoExecute for 300s\rEvents:\rType Reason Age From Message\r---- ------ ---- ---- -------\rWarning FailedScheduling \u0026lt;unknown\u0026gt; default-scheduler 0/9 nodes are available: 9 node(s) had taints that the pod didn\u0026#39;t tolerate.\rWarning FailedScheduling \u0026lt;unknown\u0026gt; default-scheduler 0/9 nodes are available: 9 node(s) had taints that the pod didn\u0026#39;t tolerate. Maintenant, enlevons une tare d\u0026rsquo;un noeud et voyons ce qui se passe :\nkubectl get nodes NAME STATUS ROLES AGE VERSION\rminikube Ready control-plane,master 120m v1.23.1\rminikube-m02 Ready \u0026lt;none\u0026gt; 119m v1.23.1 Choisissez un n≈ìud.\nkubectl taint node minikube-m02 color:NoSchedule- node/minikube-m02 untainted kubectl describe nodes | egrep \u0026#34;Name:|Taints:\u0026#34; Name: minikube\rTaints: color=blue:NoSchedule\rName: minikube-m02\rTaints: \u0026lt;none\u0026gt; Et vous devriez voir le pod en attente programm√© sur le nouveau n≈ìud non taint.\nkubectl get pods NAME READY STATUS RESTARTS AGE\rmyboot-7f84d7cfc9-2m4lh 1/1 Running 0 7m Supprimer les ressources\nkubectl delete -f apps/kubefiles/myboot-nginx-deployment.yml\rkubectl taint node minikube-m02 color=blue:NoSchedule Tolerations Cr√©ons un Pod mais contenant une tol√©rance, afin qu\u0026rsquo;il puisse √™tre programm√© vers un n≈ìud taint.\nspec:\rtolerations:\r- key: \u0026#34;color\u0026#34;\roperator: \u0026#34;Equal\u0026#34;\rvalue: \u0026#34;blue\u0026#34;\reffect: \u0026#34;NoSchedule\u0026#34;\rcontainers:\r- name: myboot\rimage: nginx vim apps/kubefiles/myboot-toleration.yaml apiVersion: apps/v1\rkind: Deployment\rmetadata:\rlabels:\rapp: myboot\rname: myboot\rspec:\rreplicas: 1\rselector:\rmatchLabels:\rapp: myboot\rtemplate:\rmetadata:\rlabels:\rapp: myboot\rspec:\rtolerations:\r- key: \u0026#34;color\u0026#34;\roperator: \u0026#34;Equal\u0026#34;\rvalue: \u0026#34;blue\u0026#34;\reffect: \u0026#34;NoSchedule\u0026#34;\rcontainers:\r- name: myboot\rimage: nginx\rports:\r- containerPort: 8080 kubectl apply -f apps/kubefiles/myboot-toleration.yaml\rkubectl get pods NAME READY STATUS RESTARTS AGE\rmyboot-84b457458b-mbf9r 1/1 Running 0 3m18s Maintenant, bien que tous les n≈ìuds contiennent une taint, le Pod est programm√© et ex√©cut√© comme nous avons d√©fini une tol√©rance contre la taint color=blue.\nSupprimer les ressources\nkubectl delete -f apps/kubefiles/myboot-toleration.yaml Pas d\u0026rsquo;ex√©cution de taint Jusqu\u0026rsquo;√† pr√©sent, vous avez vu l\u0026rsquo;effet du d√©faut NoSchedule qui signifie que les pods nouvellement cr√©√©s ne seront pas planifi√©s √† cet endroit, √† moins qu\u0026rsquo;ils ne disposent d\u0026rsquo;une tol√©rance prioritaire. Mais remarquez que si nous ajoutons cette taint √† un n≈ìud qui a d√©j√† des pods en cours d\u0026rsquo;ex√©cution/planifi√©s, cette taint ne les arr√™tera pas.\nChangeons cela en utilisant l\u0026rsquo;effet NoExecution.\nTout d\u0026rsquo;abord, supprimons toutes les alt√©rations pr√©c√©dentes.\nkubectl taint nodes --all=true color=blue:NoSchedule- Ensuite, d√©ployez un service :\nkubectl apply -f apps/kubefiles/myboot-nginx-deployment.yml\rkubectl get pods NAME READY STATUS RESTARTS AGE\rmyboot-7f889dd6d-bkfg5 1/1 Running 0 16s kubectl get pod myboot-7f889dd6d-bkfg5 -o json | jq \u0026#39;.spec.nodeName\u0026#39; \u0026#34;minikube-m02\u0026#34; kubectl taint node minikube-m02 color=blue:NoExecute\rkubectl get pods NAME READY STATUS RESTARTS AGE\rmyboot-7f889dd6d-8fm2v 1/1 Running 0 14s\rmyboot-7f889dd6d-bkfg5 1/1 Terminating 0 5m51s Si vous avez plus de n≈ìuds disponibles, alors le Pod est termin√© et d√©ploy√© sur un autre n≈ìud, si ce n\u0026rsquo;est pas le cas, alors le Pod restera en statut Pending.\nVous pouvez observer cette \u0026ldquo;reprogrammation\u0026rdquo; √† l\u0026rsquo;aide de -o wide.\nwatch kubectl get pods -o wide NAME READY STATUS RESTARTS AGE IP NODE\rmyboot-7f889dd6d-b9tks 1/1 Running 0 6s 10.88.0.5 minikube\rmyboot-7f889dd6d-l897f 1/1 Terminating 0 9m11s 172.17.0.4 minikube-m02 Supprimer les ressources\nkubectl delete -f apps/kubefiles/myboot-deployment.yml Et supprimer la taint NoExecute\nkubectl taint node minikube-m02 color=blue:NoExecute- Affinit√© et antiaffinit√© Il existe une autre fa√ßon de changer l\u0026rsquo;endroit o√π les Pods sont programm√©s en utilisant l\u0026rsquo;affinit√© et l\u0026rsquo;anti-affinit√© Node/Pod. Vous pouvez cr√©er des r√®gles qui non seulement interdisent les endroits o√π les Pods peuvent s\u0026rsquo;ex√©cuter mais aussi qui favorisent les endroits o√π ils doivent s\u0026rsquo;ex√©cuter.\nEn plus de cr√©er des affinit√©s entre les pods et les n≈ìuds, vous pouvez √©galement cr√©er des affinit√©s entre les pods. Vous pouvez d√©cider qu\u0026rsquo;un groupe de pods doit toujours √™tre d√©ploy√© ensemble sur le(s) m√™me(s) n≈ìud(s). Des raisons telles qu\u0026rsquo;une communication r√©seau importante entre les Pods et vous voulez √©viter les appels r√©seau externes ou peut-√™tre les p√©riph√©riques de stockage partag√©s.\nAffinit√© des n≈ìuds D√©ployons un nouveau pod avec une affinit√© de n≈ìud :\nspec:\raffinity:\rnodeAffinity:\rrequiredDuringSchedulingIgnoredDuringExecution:\rnodeSelectorTerms:\r- matchExpressions:\r- key: color\roperator: In\rvalues:\r- blue\rcontainers:\r- name: myboot\rimage: nginx vim apps/kubefiles/myboot-node-affinity.yml apiVersion: apps/v1\rkind: Deployment\rmetadata:\rlabels:\rapp: myboot\rname: myboot\rspec:\rreplicas: 1\rselector:\rmatchLabels:\rapp: myboot\rtemplate:\rmetadata:\rlabels:\rapp: myboot\rspec:\raffinity:\rnodeAffinity:\rrequiredDuringSchedulingIgnoredDuringExecution:\rnodeSelectorTerms:\r- matchExpressions:\r- key: color\roperator: In\rvalues:\r- blue\rcontainers:\r- name: myboot\rimage: nginx\rports:\r- containerPort: 8080 kubectl apply -f apps/kubefiles/myboot-node-affinity.yml\rkubectl get pods NAME READY STATUS RESTARTS AGE\rmyboot-54d788fdc8-f6wks 0/1 Pending 0 13s Cr√©ons une √©tiquette sur un n≈ìud correspondant √† l\u0026rsquo;expression d\u0026rsquo;affinit√© :\nkubectl get nodes NAME STATUS ROLES AGE VERSION\rminikube Ready control-plane,master 27m v1.23.1\rminikube-m02 Ready \u0026lt;none\u0026gt; 25m v1.23.1 NAME STATUS ROLES AGE VERSION\rminikube Ready control-plane,master 27m v1.23.1\rminikube-m02 Ready \u0026lt;none\u0026gt; 25m v1.23.1 kubectl label nodes minikube-m02 color=blue node/minikube-m02 labeled kubectl get pods NAME READY STATUS RESTARTS AGE\rmyboot-54d788fdc8-f6wks 1/1 Running 0 7m57s Supprimons l\u0026rsquo;√©tiquette du n≈ìud :\nkubectl label nodes minikube-m02 color-\rkubectl get pods NAME READY STATUS RESTARTS AGE\rmyboot-54d788fdc8-f6wks 1/1 Running 0 7m57s Comme pour les taints, la r√®gle est d√©finie pendant la phase d\u0026rsquo;ordonnancement, par cons√©quent, le Pod n\u0026rsquo;est pas supprim√©.\nIl s\u0026rsquo;agit d\u0026rsquo;un exemple de r√®gle stricte, si le planificateur de Kubernetes ne trouve pas de n≈ìud avec l\u0026rsquo;√©tiquette requise, le pod est rappel√© dans l\u0026rsquo;√©tat Pending. Il est √©galement possible de cr√©er une r√®gle souple, dans laquelle le planificateur Kubernetes tente de r√©pondre aux r√®gles, mais s\u0026rsquo;il n\u0026rsquo;y parvient pas, le pod est programm√© vers n\u0026rsquo;importe quel n≈ìud. Dans l\u0026rsquo;exemple ci-dessous, vous pouvez voir l\u0026rsquo;utilisation du mot pr√©f√©r√© par rapport au mot requis.\nspec:\raffinity:\rnodeAffinity:\rpreferredDuringSchedulingIgnoredDuringExecution:\r- weight: 1\rpreference:\rmatchExpressions:\r- key: color\roperator: In\rvalues:\r- blue Supprimer les ressources\nkubectl delete -f apps/kubefiles/myboot-node-affinity.yml Pod Affinity/Anti-Affinity D√©ployons un nouveau pod avec un Pod Affinity :\nspec:\raffinity:\rpodAffinity:\rrequiredDuringSchedulingIgnoredDuringExecution:\r- topologyKey: kubernetes.io/hostname (1)\rlabelSelector:\rmatchExpressions:\r- key: app\roperator: In\rvalues:\r- myboot (2)\rcontainers: 1- La cl√© de l\u0026rsquo;√©tiquette du n≈ìud. Si deux noeuds sont √©tiquet√©s avec cette cl√© et ont des valeurs identiques, l\u0026rsquo;ordonnanceur traite les deux noeuds comme √©tant dans la m√™me topologie. Dans ce cas, le nom d\u0026rsquo;h√¥te est une √©tiquette qui est diff√©rente pour chaque noeud. 2- L\u0026rsquo;affinit√© est avec les pods √©tiquet√©s avec app=myboot.\nvim apps/kubefiles/myboot-pod-affinity.yml apiVersion: apps/v1\rkind: Deployment\rmetadata:\rlabels:\rapp: myboot2\rname: myboot2\rspec:\rreplicas: 1\rselector:\rmatchLabels:\rapp: myboot2\rtemplate:\rmetadata:\rlabels:\rapp: myboot2\rspec:\raffinity:\rpodAffinity:\rrequiredDuringSchedulingIgnoredDuringExecution:\r- topologyKey: kubernetes.io/hostname\rlabelSelector:\rmatchExpressions:\r- key: app\roperator: In\rvalues:\r- myboot\rcontainers:\r- name: myboot\rimage: nginx\rports:\r- containerPort: 8080 kubectl apply -f apps/kubefiles/myboot-pod-affinity.yml\rkubectl get pods NAME READY STATUS RESTARTS AGE\rmyboot2-784bc58c8d-j2l74 0/1 Pending 0 19s Le Pod myboot2 est en attente car il n\u0026rsquo;a pas pu trouver de Pod correspondant √† la r√®gle d\u0026rsquo;affinit√©. D√©ployons l\u0026rsquo;application myboot √©tiquet√©e avec app=myboot.\nkubectl apply -f apps/kubefiles/myboot-nginx-deployment.yml\rkubectl get pods NAME READY STATUS RESTARTS AGE\rmyboot-7f889dd6d-tr7gr 1/1 Running 0 3m27s\rmyboot2-64566b697b-snm7p 1/1 Running 0 18s Maintenant, les deux applications sont ex√©cut√©es dans le m√™me n≈ìud :\nkubectl get pod myboot-7f889dd6d-tr7gr -o json | jq \u0026#39;.spec.nodeName\u0026#39; minikube kubectl get pod myboot2-64566b697b-snm7p -o json | jq \u0026#39;.spec.nodeName\u0026#39; minikube Ce que vous avez vu ici est une r√®gle stricte, vous pouvez √©galement utiliser des r√®gles \u0026ldquo;douces\u0026rdquo; dans Pod Affinity.\nspec:\raffinity:\rpodAntiAffinity:\rpreferredDuringSchedulingIgnoredDuringExecution:\r- weight: 1\rpodAffinityTerm:\rtopologyKey: kubernetes.io/hostname\rlabelSelector:\rmatchExpressions:\r- key: app\roperator: In\rvalues:\r- myboot L\u0026rsquo;anti-affinit√© est utilis√©e pour s\u0026rsquo;assurer que deux pods ne fonctionnent PAS ensemble sur le m√™me n≈ìud.\nspec:\raffinity:\rpodAntiAffinity:\rrequiredDuringSchedulingIgnoredDuringExecution:\r- topologyKey: kubernetes.io/hostname\rlabelSelector:\rmatchExpressions:\r- key: app\roperator: In\rvalues:\r- myboot D√©ployer un myboot3 avec une r√®gle d\u0026rsquo;anti-affinit√©\nvim apps/kubefiles/myboot-pod-antiaffinity.yaml apiVersion: apps/v1\rkind: Deployment\rmetadata:\rlabels:\rapp: myboot3\rname: myboot3\rspec:\rreplicas: 1\rselector:\rmatchLabels:\rapp: myboot3\rtemplate:\rmetadata:\rlabels:\rapp: myboot3\rspec:\raffinity:\rpodAntiAffinity:\rrequiredDuringSchedulingIgnoredDuringExecution:\r- topologyKey: kubernetes.io/hostname\rlabelSelector:\rmatchExpressions:\r- key: app\roperator: In\rvalues:\r- myboot\rcontainers:\r- name: myboot\rimage: nginx\rports:\r- containerPort: 8080 kubectl apply -f apps/kubefiles/myboot-pod-antiaffinity.yaml Puis utilisez la commande kubectl get pods -o wide pour voir quels pods atterrissent sur quels noeuds.\nkubectl get pods -o wide NAME READY STATUS RESTARTS AGE IP NODE\rmyboot-7f889dd6d-tr7gz 1/1 Running 0 4m27s 10.88.0.9 minikube\rmyboot2-64566b697b-snm7p 1/1 Running 0 48s 10.88.0.10 minikube\rmyboot3-78656b637r-suy1t 1/1 Running 0 1s 172.17.0.2 minikube-m02 Le pod myboot3 est d√©ploy√© dans un n≈ìud diff√©rent de celui du pod myboot.\nSupprimer les ressources\nkubectl delete -f apps/kubefiles/myboot-pod-affinity.yml\rkubectl delete -f apps/kubefiles/myboot-pod-antiaffinity.yml\rkubectl delete -f apps/kubefiles/myboot-deployment.yml "},{"uri":"https://maxime-cls.github.io/kubernetes-tutorial/kubernetes/intermediare/job_cronjob/","title":"Job &amp; CronJob","tags":[],"description":"","content":"Pr√©requis Minikube Install Driver none kubectl Install Stern Docs Release jq Install 3 terminal SSH Preparation Si vous ex√©cutez ce tutoriel dans Minikube, vous devez d√©ployer un seul noeud :\nminikube stop\rminikube delete --all\rminikube start --vm-driver=none La plupart du temps, vous utilisez Kubernetes comme plateforme pour ex√©cuter des processus \u0026ldquo;longs\u0026rdquo; dont l\u0026rsquo;objectif est de fournir des r√©ponses √† une requ√™te entrante donn√©e.\nMais Kubernetes vous permet √©galement d\u0026rsquo;ex√©cuter des processus dont le but est d\u0026rsquo;ex√©cuter une certaine logique (par exemple, mise √† jour de la base de donn√©es, traitement par lots, \u0026hellip;) et de mourir.\nLes Jobs Kubernetes sont des t√¢ches qui ex√©cutent une certaine logique une fois.\nLes CronJobs de Kubernetes sont des t√¢ches qui se r√©p√®tent en suivant un mod√®le Cron.\nAjouter des n≈ìuds suppl√©mentaires pour ex√©cuter cette partie du tutoriel. V√©rifiez le nombre de n≈ìuds que vous avez delpoy√©s en ex√©cutant :\nJob Un job est cr√©√© √† l\u0026rsquo;aide de la ressource Kubernetes Job :\nvim apps/kubefiles/whalesay-job.yaml apiVersion: batch/v1\rkind: Job\rmetadata:\rname: whale-say-job\rspec: template:\rspec:\rcontainers:\r- name: whale-say-container\rimage: docker/whalesay\rcommand: [\u0026#34;cowsay\u0026#34;,\u0026#34;Hello Kubernetes Team\u0026#34;]\rrestartPolicy: Never kubectl apply -f apps/kubefiles/whalesay-job.yaml\rwatch kubectl get pods NAME READY STATUS RESTARTS AGE\rwhale-say-job-lp4n5 0/1 ContainerCreating 0 9s\rNAME READY STATUS RESTARTS AGE\rwhale-say-job-lp4n5 1/1 Running 0 19s\rNAME READY STATUS RESTARTS AGE\rwhale-say-job-lp4n5 0/1 Completed 0 25s Vous pouvez obtenir des emplois comme toute autre ressource Kubernetes :\nkubectl get jobs NAME COMPLETIONS DURATION AGE\rwhale-say-job 1/1 20s 36s Pour obtenir le r√©sultat de l\u0026rsquo;ex√©cution du job :\nkubectl logs whale-say-job-lp4n5 _______________________\r\u0026lt; Hello Kubernetes Team \u0026gt;\r-----------------------\r\\\r\\\r\\\r## .\r## ## ## ==\r## ## ## ## ===\r/\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;___/ ===\r~~~ {~~ ~~~~ ~~~ ~~~~ ~~ ~ / ===- ~~~\r\\______ o __/\r\\ \\ __/\r\\____\\______/ Supprimer les ressources\nkubectl delete -f apps/kubefiles/whalesay-job.yaml CronJobs Un CronJob est d√©fini √† l\u0026rsquo;aide de la ressource Kubernetes CronJob :\nvim apps/kubefiles/whalesay-cronjob.yaml apiVersion: batch/v1beta1\rkind: CronJob\rmetadata:\rname: whale-say-cronjob\rspec:\rschedule: \u0026#34;*/1 * * * *\u0026#34; (1)\rjobTemplate:\rspec:\rtemplate:\rspec:\rcontainers:\r- name: whale-say-container\rimage: docker/whalesay\rcommand: [\u0026#34;cowsay\u0026#34;,\u0026#34;Hello Kubernetes Team\u0026#34;]\rrestartPolicy: Never 1- Le travail est ex√©cut√© toutes les minutes.\nkubectl apply -f apps/kubefiles/whalesay-cronjob.yaml\rkubectl get pods NAME READY STATUS RESTARTS AGE Aucun Pod n\u0026rsquo;est en cours d\u0026rsquo;ex√©cution car le CronJob est ex√©cut√© apr√®s 1 minute.\nkubectl get cronjobs NAME SCHEDULE SUSPEND ACTIVE LAST SCHEDULE AGE\rwhale-say-cronjob */1 * * * * False 0 \u0026lt;none\u0026gt; 34s Attendez une minute :\nkubectl get pods NAME READY STATUS RESTARTS AGE\rwhale-say-cronjob-1593436740-z9tf2 0/1 Completed 0 23s kubectl get cronjobs NAME SCHEDULE SUSPEND ACTIVE LAST SCHEDULE AGE\rwhale-say-cronjob */1 * * * * False 0 48s 3m41s Remarquez qu\u0026rsquo;un champ important est le Last Schedule, qui nous indique quand un travail a √©t√© ex√©cut√© pour la derni√®re fois.\nIl est important de noter qu\u0026rsquo;un CronJob cr√©e un travail :\nkubectl get jobs NAME COMPLETIONS DURATION AGE\rwhale-say-cronjob-1593436800 1/1 3s 44s Supprimer les ressources\nkubectl delete -f apps/kubefiles/whalesay-cronjob.yaml "},{"uri":"https://maxime-cls.github.io/kubernetes-tutorial/kubernetes/intermediare/daemonset/","title":"Daemonset","tags":[],"description":"","content":"Pr√©requis Minikube Install Driver none kubectl Install Stern Docs Release jq Install 3 terminal SSH Un DaemonSet garantit que tous les n≈ìuds ex√©cutent une copie d\u0026rsquo;un Pod. Lorsque des n≈ìuds sont ajout√©s au cluster, des Pods leur sont ajout√©s automatiquement. Lorsque les n≈ìuds sont supprim√©s, ils ne sont pas replanifi√©s mais supprim√©s.\nAinsi, DaemonSet vous permet de d√©ployer un Pod sur tous les n≈ìuds.\nPreparation Si vous ex√©cutez ce tutoriel dans Minikube, vous devez d√©ployer un premier noeud en utilisant le driver docker :\nminikube stop\rminikube delete --all\rminikube start --driver=docker Si vous avez un proxy\nminikube stop\rminikube delete --all\rminikube start --docker-env HTTPS_PROXY=$HTTPS_PROXY --docker-env HTTP_PROXY=$HTTP_PROXY --docker-env=NO_PROXY=$no_proxy Ajouter des n≈ìuds suppl√©mentaires pour ex√©cuter cette partie du tutoriel. V√©rifiez le nombre de n≈ìuds que vous avez delpoy√©s en ex√©cutant :\nkubectl get nodes Si un seul n≈ìud est pr√©sent, vous devez cr√©er un nouveau n≈ìud en suivant les √©tapes suivantes :\nNAME STATUS ROLES AGE VERSION\rkube Ready master 54m v1.23.1 Ayant minikube install√© et dans votre PATH, puis ex√©cutez :\nminikube node add kubectl get nodes NAME STATUS ROLES AGE VERSION\rkube Ready master 54m v1.23.1\rkube-m02 Ready \u0026lt;none\u0026gt; 2m50s v1.23.1 Daemonset Le DaemonSet est cr√©√© √† l\u0026rsquo;aide de la ressource Kubernetes DaemonSet :\nvim apps/kubefiles/nginx-daemonset.yaml apiVersion: apps/v1\rkind: DaemonSet\rmetadata:\rname: nginx-daemonset\rlabels:\rapp: nginx-daemonset\rspec:\rselector:\rmatchLabels:\rapp: nginx-daemonset\rtemplate:\rmetadata:\rlabels:\rapp: nginx-daemonset\rspec:\rcontainers:\r- name: nginx-daemonset\rimage: nginx kubectl apply -f apps/kubefiles/nginx-daemonset.yaml\rkubectl get pods -o wide NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES\rnginx-daemonset-jl2t5 1/1 Running 0 23s 10.244.0.2 multinode \u0026lt;none\u0026gt; \u0026lt;none\u0026gt;\rnginx-daemonset-r64ql 1/1 Running 0 23s 10.244.1.2 multinode-m02 \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; Remarquez qu\u0026rsquo;une instance du pod Nginx est d√©ploy√©e sur chaque n≈ìud.\nSupprimer les ressources\nkubectl delete -f apps/kubefiles/quarkus-daemonset.yaml A vous de jouer !!! Dans K8s, les DaemonSets sont souvent utilis√©s pour configurer certaines choses sur les n≈ìuds.\nCr√©ez un DaemonSet nomm√© configurator, il doit :\n√™tre dans l\u0026rsquo;espace de noms configurator\nutiliser l\u0026rsquo;image bash\nmonter /configurator en tant que volume HostPath sur le n≈ìud sur lequel il s\u0026rsquo;ex√©cute\n√©crire aba997ac-1c89-4d64 dans le fichier /configurator/config sur son n≈ìud via la commande : section\n√™tre maintenu en fonctionnement √† l\u0026rsquo;aide de sleep 1d ou d\u0026rsquo;une commande similaire apr√®s la commande d\u0026rsquo;√©criture du fichier.\nIl n\u0026rsquo;y a pas de taint sur aucun n≈ìud, ce qui signifie qu\u0026rsquo;aucune tol√©rance n\u0026rsquo;est n√©cessaire.\n"},{"uri":"https://maxime-cls.github.io/kubernetes-tutorial/kubernetes/intermediare/statefulsets/","title":"StatefulSets","tags":[],"description":"","content":"Pr√©requis Minikube Install Driver none kubectl Install Stern Docs Release jq Install 3 terminal SSH Preparation Si vous ex√©cutez ce tutoriel dans Minikube, vous devez d√©ployer un seul noeud :\nminikube stop\rminikube delete --all\rminikube start --vm-driver=none StatefulSet Un StatefulSet fournit une identit√© unique aux Pods qui le g√®rent. Il peut √™tre utilis√© lorsque votre application n√©cessite un identifiant r√©seau unique ou un stockage de persistance √† travers la (re)programmation des pods ou une certaine garantie sur l\u0026rsquo;ordre de d√©ploiement et de mise √† l\u0026rsquo;√©chelle.\nL\u0026rsquo;un des exemples les plus typiques de l\u0026rsquo;utilisation des StatefulSets est le d√©ploiement de serveurs primaires et secondaires (par exemple, un cluster de base de donn√©es) pour lequel vous devez conna√Ætre √† l\u0026rsquo;avance le nom d\u0026rsquo;h√¥te de chacun des serveurs pour d√©marrer le cluster. De m√™me, lorsque vous effectuez une mont√©e en charge ou une descente en charge, vous souhaitez le faire dans un ordre pr√©cis (par exemple, vous souhaitez d√©marrer d\u0026rsquo;abord le n≈ìud primaire, puis le n≈ìud secondaire).\nStatefulSet est cr√©√© en utilisant la ressource Kubernetes StatefulSet avec un service sans headless :\nvim apps/kubefiles/quarkus-statefulset.yaml apiVersion: apps/v1beta1\rkind: StatefulSet\rmetadata:\rname: quarkus-statefulset\rlabels:\rapp: quarkus-statefulset\rspec:\rserviceName: \u0026#34;quarkus\u0026#34; (1)\rreplicas: 2\rtemplate:\rmetadata:\rlabels:\rapp: quarkus-statefulset\rspec:\rcontainers:\r- name: quarkus-statefulset\rimage: quay.io/rhdevelopers/quarkus-demo:v1\rports:\r- containerPort: 8080\rname: web 1- D√©finit le nom du statefulset utilis√© comme nom d\u0026rsquo;h√¥te.\nLe nom d\u0026rsquo;h√¥te suit le m√™me sch√©ma dans tous les cas serviceName + un nombre commen√ßant √† 0 et il est incr√©ment√© de un pour chaque r√©plique.\nEt un service headless :\n---\rapiVersion: v1\rkind: Service\rmetadata:\rname: quarkus-statefulset\rlabels:\rapp: quarkus-statefulset\rspec:\rports:\r- port: 8080\rname: web\rclusterIP: None (1)\rselector:\rapp: quarkus-statefulset 1- Rend le service headless.\nkubectl apply -f apps/kubefiles/quarkus-statefulset.yaml\rkubectl get pods NAME READY STATUS RESTARTS AGE\rquarkus-statefulset-0 1/1 Running 0 12s Remarquez que le nom du pod est le serviceName avec un 0, car il s\u0026rsquo;agit de la premi√®re instance.\nkubectl get statefulsets NAME READY AGE\rquarkus-statefulset 1/1 109s Maintenant, on scale l\u0026rsquo;application avec 3 instances\nkubectl scale statefulset quarkus-statefulset --replicas=3\rkubectl get pods NAME READY STATUS RESTARTS AGE\rquarkus-statefulset-0 1/1 Running 0 95s\rquarkus-statefulset-1 1/1 Running 0 2s\rquarkus-statefulset-2 1/1 Running 0 1s Remarquez que le nom des Pods utilise la m√™me nomenclature de serviceName + num√©ro incr√©mental.\nDe plus, si vous v√©rifiez l\u0026rsquo;ordre des √©v√©nements dans le cluster Kubernetes, vous remarquerez que le nom du Pod se terminant par -1 est cr√©√© en premier, puis celui se terminant par -2.\nkubectl get events --sort-by=.metadata.creationTimestamp 4m4s Normal SuccessfulCreate statefulset/quarkus-statefulset create Pod quarkus-statefulset-1 in StatefulSet quarkus-statefulset successful\r4m3s Normal Pulled pod/quarkus-statefulset-1 Container image \u0026#34;quay.io/rhdevelopers/quarkus-demo:v1\u0026#34; already present on machine\r4m3s Normal Scheduled pod/quarkus-statefulset-2 Successfully assigned default/quarkus-statefulset-2 to kube\r4m3s Normal Created pod/quarkus-statefulset-1 Created container quarkus-statefulset\r4m3s Normal Started pod/quarkus-statefulset-1 Started container quarkus-statefulset\r4m3s Normal SuccessfulCreate statefulset/quarkus-statefulset create Pod quarkus-statefulset-2 in StatefulSet quarkus-statefulset successful\r4m2s Normal Pulled pod/quarkus-statefulset-2 Container image \u0026#34;quay.io/rhdevelopers/quarkus-demo:v1\u0026#34; already present on machine\r4m2s Normal Created pod/quarkus-statefulset-2 Created container quarkus-statefulset\r4m2s Normal Started pod/quarkus-statefulset-2 Started container quarkus-statefulset Enfin, si nous r√©duisons √† deux instances, celle qui est d√©truite n\u0026rsquo;est pas choisie au hasard, mais celle qui a √©t√© lanc√©e plus tard (quarkus.statefulset-2).\nkubectl scale statefulset quarkus-statefulset --replicas=2\rkubectl get pods NAME READY STATUS RESTARTS AGE\rquarkus-statefulset-0 1/1 Running 0 9m22s\rquarkus-statefulset-1 1/1 Running 0 7m49s\rquarkus-statefulset-2 0/1 Terminating 0 7m48s Supprimer les ressources\nkubectl delete -f apps/kubefiles/quarkus-statefulset.yaml "},{"uri":"https://maxime-cls.github.io/kubernetes-tutorial/kubernetes/avance/","title":"Avanc√©","tags":[],"description":"","content":""},{"uri":"https://maxime-cls.github.io/kubernetes-tutorial/","title":"Kubernetes Tutoriel","tags":[],"description":"","content":""},{"uri":"https://maxime-cls.github.io/kubernetes-tutorial/kubernetes/","title":"Kubernetes","tags":[],"description":"","content":""},{"uri":"https://maxime-cls.github.io/kubernetes-tutorial/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://maxime-cls.github.io/kubernetes-tutorial/tags/","title":"Tags","tags":[],"description":"","content":""}]